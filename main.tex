% !TeX spellcheck = pl_PL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                        %
% Szablon pracy dyplomowej inzynierskiej %
% zgodny  z aktualnymi  przepisami  SZJK %
%                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                        %
%  (c) Krzysztof Simiński, 2018-2023     %
%                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                        %
% Najnowsza wersja szablonów jest        %
% podstępna pod adresem                  %
% github.com/ksiminski/polsl-aei-theses  %
%                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% Projekt LaTeXowy zapewnia odpowiednie formatowanie pracy,
% zgodnie z wymaganiami Systemu zapewniania jakości kształcenia.
% Proszę nie zmieniać ustawień formatowania (np. fontu,
% marginesów, wytłuszczeń, kursywy itd. ).
%
% Projekt można kompilować na kilka sposobów.
%
% 1. kompilacja pdfLaTeX
%
% pdflatex main
% bibtex   main
% pdflatex main
% pdflatex main
%
%
% 2. kompilacja XeLaTeX
%
% Kompilatacja przy użyciu XeLaTeXa różni się tym, że na stronie
% tytułowej używany jest font Calibri. Wymaga to jego uprzedniego
% zainstalowania.
%
% xelatex main
% bibtex  main
% xelatex main
% xelatex main
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% W przypadku pytań, uwag, proszę pisać na adres:   %
%      krzysztof.siminski(małpa)polsl.pl            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Chcemy ulepszać szablony LaTeXowe prac dyplomowych.
% Wypełniając ankietę spod poniższego adresu pomogą
% Państwo nam to zrobić. Ankieta jest całkowicie
% anonimowa. Dziękujemy!


% https://docs.google.com/forms/d/e/1FAIpQLScyllVxNKzKFHfILDfdbwC-jvT8YL0RSTFs-s27UGw9CKn-fQ/viewform?usp=sf_link
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% PERSONALIZACJA PRACY – DANE PRACY           %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Proszę wpisać swoje dane w poniższych definicjach.

% TODO
% dane autora
\newcommand{\FirstNameAuthor}{Imię}
\newcommand{\SurnameAuthor}{Nazwisko}
\newcommand{\IdAuthor}{$\langle$wpisać właściwy$\rangle$}   % numer albumu  (bez $\langle$ i $\rangle$)

% drugi autor:
%\newcommand{\FirstNameCoauthor}{Imię}   % Jeżeli jest drugi autor, to tutaj należy podać imię.
%\newcommand{\SurnameCoauthor}{Nazwisko} % Jeżeli jest drugi autor, to tutaj należy podać nazwisko.
%\newcommand{\IdCoauthor}{$\langle$wpisać właściwy$\rangle$}  % numer albumu drugiego autora (bez $\langle$ i $\rangle$)
% Gdy nie ma drugiego autora, należy zostawić poniższe definicje puste, jak poniżej. Gdy jest drugi autor, należy zakomentować te linie.
\newcommand{\FirstNameCoauthor}{} % Jeżeli praca ma tylko jednego autora, to dane drugiego autora zostają puste.
\newcommand{\SurnameCoauthor}{}   % Jeżeli praca ma tylko jednego autora, to dane drugiego autora zostają puste.
\newcommand{\IdCoauthor}{}  % Jeżeli praca ma tylko jednego autora, to dane drugiego autora zostają puste.
%%%%%%%%%%

\newcommand{\Supervisor}{$\langle$tytuł lub stopień naukowy oraz imię i nazwisko$\rangle$}     % dane promotora (bez $\langle$ i $\rangle$)
\newcommand{\Title}{Postcardia - Aplikacja społecznościowa do kolekcjonowania i wysyłania pocztówek}           % tytuł pracy po polsku
\newcommand{\TitleAlt}{Postcardia - Community application for collecting and sending postcards}                     % thesis title in English
\newcommand{\Program}{$\langle$wpisać właściwy$\rangle$}            % kierunek studiów  (bez $\langle$ i $\rangle$)
\newcommand{\Specialisation}{$\langle$wpisać właściwą$\rangle$}     % specjalność  (bez $\langle$ i $\rangle$)
\newcommand{\Departament}{$\langle$wpisać właściwą$\rangle$}        % katedra promotora  (bez $\langle$ i $\rangle$)

% Jeżeli został wyznaczony promotor pomocniczy lub opiekun, proszę go/ją wpisać ...
\newcommand{\Consultant}{$\langle$stopień naukowy imię i nazwisko$\rangle$} % dane promotora pomocniczego, opiekuna (bez $\langle$ i $\rangle$)
% ... w przeciwnym razie proszę zostawić puste miejsce jak poniżej:
%\newcommand{\Consultant}{} % brak promotowa pomocniczego / opiekuna

% koniec fragmentu do modyfikacji
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% KONIEC PERSONALIZACJI PRACY                 %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% PROSZĘ NIE MODYFIKOWAĆ PONIŻSZYCH USTAWIEŃ! %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\documentclass[a4paper,twoside,12pt]{book}
\usepackage[utf8]{inputenc}                                      
\usepackage[T1]{fontenc}  
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage[british,polish]{babel} 
\usepackage{indentfirst}
\usepackage{xurl}
\usepackage{xstring}
\usepackage{ifthen}
\usepackage{float}



\usepackage{ifxetex}

\ifxetex
	\usepackage{fontspec}
	\defaultfontfeatures{Mapping=tex—text} % to support TeX conventions like ``——-''
	\usepackage{xunicode} % Unicode support for LaTeX character names (accents, European chars, etc)
	\usepackage{xltxtra} % Extra customizations for XeLaTeX
\else
	\usepackage{lmodern}
\fi



\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx} 
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{subcaption}   % subfigures
\usepackage[page]{appendix} % toc,
\renewcommand{\appendixtocname}{Dodatki}
\renewcommand{\appendixpagename}{Dodatki}
\renewcommand{\appendixname}{Dodatek}

\usepackage{csquotes}
\usepackage[natbib=true,backend=bibtex,maxbibnames=99]{biblatex}  % kompilacja bibliografii BibTeXem
%\usepackage[natbib=true,backend=biber,maxbibnames=99]{biblatex}  % kompilacja bibliografii Biberem
\bibliography{biblio}

\usepackage{ifmtarg}   % empty commands  

\usepackage{setspace}
\onehalfspacing


\frenchspacing



%%%% TODO LIST GENERATOR %%%%%%%%%

\usepackage{color}
\definecolor{brickred}      {cmyk}{0   , 0.89, 0.94, 0.28}

\makeatletter \newcommand \kslistofremarks{\section*{Uwagi} \@starttoc{rks}}
  \newcommand\l@uwagas[2]
    {\par\noindent \textbf{#2:} %\parbox{10cm}
{#1}\par} \makeatother


\newcommand{\ksremark}[1]{%
{%\marginpar{\textdbend}
{\color{brickred}{[#1]}}}%
\addcontentsline{rks}{uwagas}{\protect{#1}}%
}

\newcommand{\comma}{\ksremark{przecinek}}
\newcommand{\nocomma}{\ksremark{bez przecinka}}
\newcommand{\styl}{\ksremark{styl}}
\newcommand{\ortografia}{\ksremark{ortografia}}
\newcommand{\fleksja}{\ksremark{fleksja}}
\newcommand{\pauza}{\ksremark{pauza `--', nie dywiz `-'}}
\newcommand{\kolokwializm}{\ksremark{kolokwializm}}
\newcommand{\cudzyslowy}{\ksremark{,,polskie cudzysłowy''}}

%%%%%%%%%%%%%% END OF TODO LIST GENERATOR %%%%%%%%%%%

\newcommand{\printCoauthor}{%		
    \StrLen{\FirstNameCoauthor}[\FNCoALen]
    \ifthenelse{\FNCoALen > 0}%
    {%
		{\large\bfseries\Coauthor\par}
	
		{\normalsize\bfseries \LeftId: \IdCoauthor\par}
    }%
    {}
} 

%%%%%%%%%%%%%%%%%%%%%
\newcommand{\autor}{%		
    \StrLen{\FirstNameCoauthor}[\FNCoALenXX]
    \ifthenelse{\FNCoALenXX > 0}%
    {\FirstNameAuthor\ \SurnameAuthor, \FirstNameCoauthor\ \SurnameCoauthor}%
	{\FirstNameAuthor\ \SurnameAuthor}%
}
%%%%%%%%%%%%%%%%%%%%%

\StrLen{\FirstNameCoauthor}[\FNCoALen]
\ifthenelse{\FNCoALen > 0}%
{%
\author{\FirstNameAuthor\ \SurnameAuthor, \FirstNameCoauthor\ \SurnameCoauthor}
}%
{%
\author{\FirstNameAuthor\ \SurnameAuthor}
}%

%%%%%%%%%%%% ZYWA PAGINA %%%%%%%%%%%%%%%
% brak kapitalizacji zywej paginy
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LO]{\nouppercase{\it\rightmark}}
\fancyhead[RE]{\nouppercase{\it\leftmark}}
\fancyhead[LE,RO]{\it\thepage}


\fancypagestyle{tylkoNumeryStron}{%
   \fancyhf{} 
   \fancyhead[LE,RO]{\it\thepage}
}

\fancypagestyle{bezNumeracji}{%
   \fancyhf{} 
   \fancyhead[LE,RO]{}
}


\fancypagestyle{NumeryStronNazwyRozdzialow}{%
   \fancyhf{} 
   \fancyhead[LE]{\nouppercase{\autor}}
   \fancyhead[RO]{\nouppercase{\leftmark}} 
   \fancyfoot[CE, CO]{\thepage}
}


%%%%%%%%%%%%% OBCE WTRETY  
\newcommand{\obcy}[1]{\emph{#1}}
\newcommand{\english}[1]{{\selectlanguage{british}\obcy{#1}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% polskie oznaczenia funkcji matematycznych
\renewcommand{\tan}{\operatorname {tg}}
\renewcommand{\log}{\operatorname {lg}}

% jeszcze jakies drobiazgi

\newcounter{stronyPozaNumeracja}

%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newcommand{\printOpiekun}[1]{%		

    \StrLen{\Consultant}[\mystringlen]
    \ifthenelse{\mystringlen > 0}%
    {%
       {\large{\bfseries OPIEKUN, PROMOTOR POMOCNICZY}\par}
       
       {\large{\bfseries \Consultant}\par}
    }%
    {}
} 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
% Proszę nie modyfikować poniższych definicji!
\newcommand{\Author}{\FirstNameAuthor\ \MakeUppercase{\SurnameAuthor}} 
\newcommand{\Coauthor}{\FirstNameCoauthor\ \MakeUppercase{\SurnameCoauthor}}
\newcommand{\Type}{PROJEKT INŻYNIERSKI}
\newcommand{\Faculty}{Wydział Matematyki Stosowanej} 
\newcommand{\Polsl}{Politechnika Śląska}
\newcommand{\Logo}{politechnika_sl_logo_bw_pion_pl.pdf}
\newcommand{\LeftId}{Nr albumu}
\newcommand{\LeftProgram}{Kierunek}
\newcommand{\LeftSpecialisation}{Specjalność}
\newcommand{\LeftSUPERVISOR}{PROWADZĄCY PRACĘ}
\newcommand{\LeftDEPARTMENT}{KATEDRA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% KONIEC USTAWIEŃ                             %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% MOJE PAKIETY, USTAWIENIA ITD                %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tutaj proszę umieszczać swoje pakiety, makra, ustawienia itd.


 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% listingi i fragmentu kodu źródłowego 
% pakiet: listings lub minted
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% biblioteka listings
%stare
% \usepackage{listings}
% \lstset{%
% morekeywords={string,exception,std,vector},% słowa kluczowe rozpoznawane przez pakiet listings
% language=C++,% C, Matlab, Python, SQL, TeX, XML, bash, ... – vide https://www.ctan.org/pkg/listings
% commentstyle=\textit,%
% identifierstyle=\textsf,%
% keywordstyle=\sffamily\bfseries, %\texttt, %
% %captionpos=b,%
% tabsize=3,%
% frame=lines,%
% numbers=left,%
% numberstyle=\tiny,%
% numbersep=5pt,%
% breaklines=true,%
% escapeinside={@*}{*@},%
% }

% biblioteka listings - NOWE
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codeorange}{rgb}{1,0.647,0}
\definecolor{codeblue}{rgb}{0,0,1}

\lstset{%
    morekeywords={string,exception,std,vector},% słowa kluczowe rozpoznawane przez pakiet listings
    language=C++,% C, Matlab, Python, SQL, TeX, XML, bash, ... – vide https://www.ctan.org/pkg/listings
    commentstyle=\textit{\color{codegreen}},%
    identifierstyle=\textsf{\color{codegray}},%
    keywordstyle=[1]\sffamily\bfseries\color{codepurple},%
    keywordstyle=[2]\sffamily\bfseries\color{codeorange},%
    keywordstyle=[3]\sffamily\bfseries\color{codeblue},%
    backgroundcolor=\color{backcolour},
    %captionpos=b,%
    tabsize=3,%
    frame=lines,%
    numbers=left,%
    numberstyle=\tiny\color{codegray},%
    numbersep=5pt,%
    breaklines=true,%
    escapeinside={@*}{*@},%
}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% pakiet minted
%\usepackage{minted}

% pakiet wymaga specjalnego kompilowania:
% pdflatex -shell-escape main.tex
% xelatex  -shell-escape main.tex

%\usepackage[chapter]{minted} % [section]
%%\usemintedstyle{bw}   % czarno-białe kody 
%
%\setminted % https://ctan.org/pkg/minted
%{
%%fontsize=\normalsize,%\footnotesize,
%%captionpos=b,%
%tabsize=3,%
%frame=lines,%
%framesep=2mm,
%numbers=left,%
%numbersep=5pt,%
%breaklines=true,%
%escapeinside=@@,%
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% KONIEC MOICH USTAWIEŃ                       %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
%\kslistofremarks

\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% PROSZĘ NIE MODYFIKOWAĆ STRONY TYTUŁOWEJ!    %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%  STRONA TYTUŁOWA %%%%%%%%%%%%%%%%%%%
\pagestyle{empty}
{
	\newgeometry{top=1.5cm,%
	             bottom=2.5cm,%
	             left=3cm,
	             right=2.5cm}
 
	\ifxetex 
	  \begingroup
	  \setsansfont{Calibri}
	   
	\fi 
	 \sffamily
	\begin{center}
	\includegraphics[width=50mm]{\Logo}
	 
	
	{\Large\bfseries\Type\par}
	
	\vfill  \vfill  
			 
	{\large\Title\par}
	
	\vfill  
		
	{\large\bfseries\Author\par}
	
	{\normalsize\bfseries \LeftId: \IdAuthor}

	\printCoauthor
	
	\vfill  		
 
	{\large{\bfseries \LeftProgram:} \Program\par} 
	
	{\large{\bfseries \LeftSpecialisation:} \Specialisation\par} 
	 		
	\vfill  \vfill 	\vfill 	\vfill 	\vfill 	\vfill 	\vfill  
	 
	{\large{\bfseries \LeftSUPERVISOR}\par}
	
	{\large{\bfseries \Supervisor}\par}
				
	{\large{\bfseries \LeftDEPARTMENT\ \Departament} \par}
		
	{\large{\bfseries \Faculty}\par}
		
	\vfill  \vfill  

    	
    \printOpiekun{\Consultant}
    
	\vfill  \vfill  
		
    {\large\bfseries  Gliwice \the\year}

   \end{center}	
       \ifxetex 
       	  \endgroup
       \fi
	\restoregeometry
}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                             %
% KONIEC STRONY TYTUŁOWEJ                     %
%                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


\cleardoublepage

\rmfamily\normalfont
\pagestyle{empty}


%%% No to zaczynamy pisać pracę :-) %%%%

% TODO
\subsubsection*{Tytuł pracy} 
\Title

\subsubsection*{Streszczenie}  
Praca prezentuje rezultaty oraz proces tworzenia aplikacji społecznościowej której głównym celem jest kolekcjonowanie oraz wysyłanie pocztówek z odwiedzonych miejsc. Głównym trzonem aplikacji jest jej część mobilna oparta na platformie Flutter, której działanie wspierane jest poprzez dedykowaną aplikację serwerową wykorzystującą technologię .NET. Dodatkowo aplikacja zawiera także oddzielną część webową wykorzystującą technologię React, część ta korzysta z tej samej aplikacji serwerowej co aplikacja mobilna.

\subsubsection*{Słowa kluczowe} 
Flutter, .NET, React, CRUD, Pocztówki, Aplikacja społecznościowa, Zwiedzanie

\subsubsection*{Thesis title} 
\begin{otherlanguage}{british}
\TitleAlt
\end{otherlanguage}

\subsubsection*{Abstract} 
\begin{otherlanguage}{british}
The thesis presents the results and the process of creating a social application whose main purpose is to collect and send postcards from visited places. The core of the application is its mobile component built on the Flutter platform, supported by a dedicated server application utilizing .NET technology. Additionally, the application includes a separate web component using React technology, and this web part utilizes the same server application as the mobile application.
\end{otherlanguage}
\subsubsection*{Key words}  
\begin{otherlanguage}{british}
Flutter, .NET, React, CRUD, Postcards, Community app, Touring
\end{otherlanguage}




%%%%%%%%%%%%%%%%%% SPIS TRESCI %%%%%%%%%%%%%%%%%%%%%%
% Add \thispagestyle{empty} to the toc file (main.toc), because \pagestyle{empty} doesn't work if the TOC has multiple pages
\addtocontents{toc}{\protect\thispagestyle{empty}}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{stronyPozaNumeracja}{\value{page}}
\mainmatter
\pagestyle{empty}

\cleardoublepage

\pagestyle{NumeryStronNazwyRozdzialow}

%%%%%%%%%%%%%% wlasciwa tresc pracy %%%%%%%%%%%%%%%%%

% TODO
\chapter{Wstęp}
\label{ch:wstep}

\section{Wprowadzenie}
% Aplikacje społecznościowe w dzisiejszym świecie są dla czymś powszechnym. Większość z nich sprowadza się do wysyłania zdjęć oraz wymieniania wiadomości. Przed erą smartfonów takie informacje były bardziej spersonalizowane, ponieważ służyły do tego listy na których pisaliśmy co robimy, oraz pocztówki dzięki którym mogliśmy pokazać gdzie jesteśmy. Właśnie to drugie zainspirowało nas do połączenia starego z nowym - pocztówek z aplikacją społecznościową. Chcemy, aby odwiedzanie różnych miejsc, czy to lokalnie, blisko, czy tych na drugim końcu świata, łączyło się z czymś kiedyś powszechnym czyli wysyłaniem pocztówek. Wszak cieszymy się bardziej z pocztówki wysłanej przez rodzinę lub przyjaciela niż ze zdjęcia na Facebooku. 

Aplikacje społecznościowe w dzisiejszym świecie są dla czymś powszechnym. Większość z nich sprowadza się do wysyłania zdjęć oraz wymieniania wiadomości.  Przed erą smartfonów takie informacje były bardziej spersonalizowane, ponieważ służyły do tego listy na których pisaliśmy co robimy, oraz pocztówki dzięki którym mogliśmy pokazać gdzie jesteśmy. Właśnie to drugie zainspirowało nas do połączenia starego z nowym - pocztówek z aplikacją społecznościową.

Chcemy, aby podróżowanie i odwiedzanie różnych miejsc, zarówno lokalnych, blisko, jak i tych na drugim końcu świata, było związane z czymś kiedyś powszechnym - wysyłaniem pocztówek. Wszyscy z pewnością cieszymy się bardziej z pocztówki wysłanej przez kogoś nam bliskiego niż ze zwykłego zdjęcia na znanym portalu społecznościowym. W związku z tym nasza aplikacja umożliwia użytkownikom odbieranie wirtualnych pocztówek podczas odwiedzania ciekawych miejsc. Później te elektroniczne pocztówki można przesłać innym osobom jako miłe wiadomości lub po prostu w celach kolekcjonerskich.

Ze względu na ograniczoną ilość osób, którym możemy przekazać wirtualne pocztówki, każda z nich staje się wyjątkowa i posiada większą wartość dla odbiorcy niż wcześniej wspomniane zdjęcie na tablicy popularnego portalu społecznościowego. Nasza aplikacja stanowi również doskonały sposób na poszerzenie kolekcji miejsc, które użytkownik odwiedził.

\newpage

\section{Cel pracy}
Celem naszej pracy jest stworzenie wyjątkowej w pełni działającej aplikacji mobilnej umożliwiającej na zawiązywanie znajomości, wymianę oraz kolekcjonowanie pocztówek z odwiedzonych miejsc. Dodatkowo celem jest stworzenie aplikacji webowej umożliwiającą wykonanie większości czynności z~aplikacji mobilnej, jak i również backendu działającego na obu platformach odpowiedzialnego za część serwerową. Aplikacja mobilna oraz webowa powinna być intuicyjna i łatwa w obsłudze, oraz zachęcać użytkowników do aktywnego wypoczynku (zwiedzania) oraz rozwijania się w aspekcie społecznym poprzez wysyłanie oraz odbieranie wyjątkowych pocztówek z różnych ciekawych miejsc w okolicy jak i na całym świecie.

\section{Zakres pracy}
Zakres pracy obejmował zaprojektowanie intuicyjnej i wyjątkowej aplikacji składającej się z trzech głównych modułów oraz jej kompleksową implementację.
\\
Poszczególne moduły:
\begin{itemize}
    \item Aplikacji mobilnej stworzonej w technologi Flutter.
    \item Aplikacji serwerowej stworzonej w technologi .Net.
    \item Aplikacji webowej stworzonej w technologi React.
\end{itemize}

Przed przejściem do fazy implementacji w każdym module najpierw przeprowadzono fazę projektowania, mającą na celu ocenę sensowności oraz zdefiniowanie kluczowych aspektów modułu. 

Zakres pracy przewidywał także przeprowadzenie odpowiednich testów jak i analizę jakości utworzonego projektu oraz stworzenie szczegółowej dokumentacji technicznej opisującej działanie, architekturę i wykorzystane technologie.

\newpage

\section{Zwięzła charakterystyka rozdziałów}
\begin{itemize}
    \item \textbf{Rozdział 1:} Wstęp -- Zaprezentowanie ogólnego kontekstu oraz celów pracy
    \item \textbf{Rozdział 2:} Analiza tematu -- W tym rozdziale przedstawiony zostanie problem, poszczególne podobne aplikacje oraz rozwiązania z rzeczywistości, nakreślenie przykładowego profilu konsumenta aplikacji oraz przedstawienie wyróżniających nasz projekt rozwiązań
    \item \textbf{Rozdział 3:} Wymagania -- Przedstawienie wymagań funkcjonalnych jak i niefunkcjonalnych
    \item \textbf{Rozdział 4:} Metodyka pracy nad projektowaniem i implementacją -- opis wykorzystanej metodyki podczas fazy projektowania jak i implementacji, użyte narzędzia, pomysły, workflow w projekcie
    \item \textbf{Rozdział 5:} Aplikacja mobilna -- Szeroki opis dotyczący aplikacji mobilnej, wykorzystanych bibliotek, zastosowanej architektury jak i instrukcja obsługi
    \item \textbf{Rozdział 6:} Aplikacja serwerowa -- Szeroki opis dotyczący aplikacji serwerowej, wykorzystanych technilogii oraz platform, zastosowanej architektury  oraz struktury, wykorzystane modele, szczegóły dotyczące specyfikacji oraz funkcjonalności. Przeprowadzone testy automatyczne oraz manualne
    \item \textbf{Rozdział 7:} Aplikacja webowa -- Szeroki opis dotyczący aplikacji webowej,
    \item \textbf{Rozdział 8:} Podsumowanie i wnioski -- Przedstawienie potencjalnego sposobu na dalszy rozwój aplikacji, omówienie napotkanych problemów i trudności podczas tworzenia jak i projektowania aplikacji, wyciągnięcie wniosków w świetle postawionych wcześniej celów i wymagań
\end{itemize}

\newpage

\section{Autorzy}
Aplikacja była tworzona przez czteroosobowy zespół, początkowo najwięcej zasobów ludzkich zostało przeznaczonych na stworzenie aplikacji mobilnej, która docelowo miała być głównym produktem projektu. Ze względu na sprawny przebieg prac w części mobilnej oraz serwerowej, część osób została oddelegowana do pomocy z aplikacją webową. Szczegóły przedstawia poniższa tabela:
\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Osoba} & \textbf{Część mobilna} & \textbf{Część webowa} & \textbf{Część serwerowa} \\ \hline
\textbf{Patryk Sroczyński}    &               & Pomoc            & Głównie      \\ \hline
\textbf{Arkadiusz Stencel}    & Głównie       &                  &              \\ \hline
\textbf{Dawid Strzyż}         &               & Głównie          &              \\ \hline
\textbf{Mariusz Wróbel}       & Głównie       & Pomoc            &              \\ \hline
\end{tabular}
\caption{Autorstwo poszczególnych elementów pracy.}
\end{table}


% TODO
\chapter{Analiza tematu}

\section{Sformułowanie problemu}
\section{Przegląd podobnych aplikacji oraz rozwiązań}
\subsection{Snapchat}

\subsection{Pokemon GO}


\subsection{Slowly}


\subsection{Pieczątki PTTK}


\subsection{Tradycyjne Pocztówki}


\section{Docelowy odbiorca}


\section{Uzasadnienie wyboru}

%%%%%%%%%%%%%%%%%%%%%%%%





% TODO
\chapter{Wymagania}
\label{ch:wymagania}

\section{Wymagania funkcjonalne}


\section{Wymagania niefunkcjonalne}




%%%%%%%%%%%%%%%%%%%%%
%% RYSUNEK Z PLIKU
%
%\begin{figure}
%\centering
%\includegraphics[width=0.5\textwidth]{./politechnika_sl_logo_bw_pion_pl.pdf}
%\caption{Podpis rysunku zawsze pod rysunkiem.}
%\label{fig:etykieta-rysunku}
%\end{figure}
%Rys. \ref{fig:etykieta-rysunku} przestawia …
%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%
%% WIELE RYSUNKÓW 
%
%\begin{figure}
%\centering
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Lewy górny rysunek.}
%    \label{fig:lewy-gorny}
%\end{subfigure}
%\hfill
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Prawy górny rysunek.}
%    \label{fig:prawy-gorny}
%\end{subfigure}
%
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Lewy dolny rysunek.}
%    \label{fig:lewy-dolny}
%\end{subfigure}
%\hfill
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Prawy dolny rysunek.}
%    \label{fig:prawy-dolny}
%\end{subfigure}
%        
%\caption{Wspólny podpis kilku rysunków.}
%\label{fig:wiele-rysunkow}
%\end{figure}
%Rys. \ref{fig:wiele-rysunkow} przestawia wiele ważnych informacji, np. rys. \ref{fig:prawy-gorny} jest na prawo u góry.
%%%%%%%%%%%%%%%%%%%%%



\chapter{Metodyka pracy nad projektowaniem i implementacją}
\label{ch:Metodyka}

\section{Opis użytych narzędzi}

\begin{itemize}
    \item \textbf{Visual Studio (IDE)} -- zintegrowane środowisko programistyczne  
    \item \textbf{SQL Server Management Studio} -- zintegrowane środowisko bazy danych do jej obsługi, które zawiera wszystkie potrzebne funkcjonalności. 
\end{itemize}

\section{Początkowe wizje na stworzenie aplikacji}

\section{System kontroli wersji}

\section{Komunikacja w zespole}

\section{Przydzielanie zadań oraz ich wykonywanie}


 


% TODO
\chapter{Aplikacja mobilna}
\label{ch:05}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Pakiet minted wymaga importu: \usepackage{minted}                 %
% i specjalnego kompilowania:                                       %
% pdflatex -shell-escape main                                       %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

%\begin{figure}
%\centering
%\begin{minted}[linenos,frame=lines]{c++}
%class test : public basic
%{
%    public:
%      test (int a);
%      friend std::ostream operator<<(std::ostream & s, 
%                                     const test & t);
%    protected:
%      int _a;  
%      
%};
%\end{minted}
%\caption{Pseudokod w \texttt{minted}.}
%\label{fig:pseudokod:minted}
%\end{figure}




\section{Biblioteki}
W rozdziale tym zostaną omówione biblioteki użyte w projekcie. Na początku omówimy główne biblioteki każdego z modułów. W dalszych podrozdziałach omówimy biblioteki dodatkowe, które wchodzą w skład modułów dodając do nich nowe funkcjonalności lub rozwijając już te istniejące.
\subsection{Biblioteka główna mobilna}
\begin{itemize}
    \item Flutter - jest to technologia stworzona przez firmę Google pozwalająca na tworzenie aplikacji na urządzenia z systemami Android jak i iOS używając tego samego kodu. Językiem wykorzystywanym podczas tworzenia tych aplikacji jest Dart, który również został stworzony przez Google. Napisane we Flutterze aplikacje mobilne wyglądają i działają niemal identycznie na obu systemach z wydajnością, która jest bardzo zbliżona do aplikacji natywnych. Fluttera tworzą dwa podstawowe elementy którymi są framework, który jest niezbędny do poprawnego działania aplikacji oraz pakiet SDK, który jest konieczny do ich tworzenia.
\end{itemize}
\subsection{Biblioteki mobilne dodatkowe}
\begin{itemize}
    \item intl - umożliwia stworzenie pliku zawierającego wszystkie wiadomości zawierające się w aplikacji oraz używanie odpowiednich plików z językami w zależności od ustawień.
    \item http - jest to biblioteka umożliwiająca komunikację pomiędzy aplikacją a serwerem przy użyciu żądań HTTP.
    \item flutter\_bloc - biblioteka, która zawiera w sobie widgety, ułatwiająca wprowadzenie BLoC jako state management w aplikacji.
    \item flutter\_secure\_storage - w aplikacji używany jest do przechowywania JWT otrzymanego podczas logowania. Biblioteka szyfruje wartości jakie otrzymuje przed umieszczeniem ich w pamięci. Na platformie Android jest używane do tego szyfrowanie AES, natomiast na platformie iOS jest to KeyChain. 
    \item jwt\_decoder - jest biblioteka do dekodowania JWT. Dzięki niej możemy sprawdzić, czy token wygasł i na podstawie tego przekierować użytkownika na odpowiednią podstronę.
    \item shimmer - biblioteka dodająca widget używany podczas ładowania danych z serwera.
    \item image\_picker - oficjalna biblioteka umożliwiająca wybieranie zdjęć z galerii lub tworzenie od razu nowych i dalsze ich wykorzystywanie w aplikacji.
    \item country\_picker - biblioteka dodająca widget do wybierania kraju.
    \item auto\_size\_text - jest to biblioteka dająca większą kontrolę nad wyświetlanym tekstem. Dzięki niej łatwo możemy skalować tekst na mniejszych ekranach lub ustawiać limit wierszy przy zawijaniu.
    \item background\_locator\_2 - jest to jedna z istotniejszych bibliotek w naszej aplikacji. Służy ona na do pobierania z telefonu koordynatów. Funkcja kontynuuje działanie, nawet gdy aplikacja działa w tle lub gdy jest całkowicie wyłączona. Biblioteka jest również rozwinięta o funkcje callback, która jest wykonywana za każdym razem gdy pobierane są nowe koordynaty co umożliwia nam wykonywanie wtedy innych funkcji, nawet gdy aplikacja jest wyłączona.
    \item path\_provider - biblioteka wykorzystywana do lokalizowanie plików w systemie.
    \item location\_permissions - umożliwia pobieranie lokalizacji z urządzenia. 
    \item permission\_handler - biblioteka, która obsługuje nadawanie oraz sprawdzanie istniejących zgód na wykorzystywanie poszczególnych serwisów w urządzeniu, takich jak powiadomienia lub pamięć. 
    \item geolocator - biblioteka, która pozwala na komunikację z serwisem odpowiedzialnym za lokalizację. W projekcie jest wykorzystywana w celu sprawdzenia czy lokalizacja jest ciągle włączona na urządzeniu. 
    \item cached\_memory\_image - biblioteka umożliwiająca zapisywanie grafik w pamięci telefonu co eliminuje miganie obrazów podczas ich ciągłego pobierania.
    \item url\_launcher - umożliwia otwieranie linków w osobnej karcie przeglądarki na użądzeniach mobilnych. 
    \item loading\_animation\_widget - biblioteka zawierająca animacje ładowania.
    \item flutter\_animate - biblioteka umożliwiająca animowania dowolnego widgetu w aplikacji.
    \item easy\_debounce - biblioteka upraszczająca oryginalny zapis debouncera języka Dart. 
    \item shared\_preferences - służy do zapisywania różnych zmiennych w pamięci telefonu jako pary klucz-wartość w podobny sposób jak to robi secure storage. 
    \item app\_settings - umożliwia otworzenie ustawień telefonu z poziomu aplikacji.
    \item provider - jest to biblioteka do zarządzania stanem aplikacji. Umożliwia na przebudowanie widoku gdy Consumer wykryje zmianę wartości zmiennej.
    \item flutter\_local\_notifications - biblioteka umożliwiająca wykonywanie lokalnych powiadomień typu ``push'', nawet gdy aplikacja jest wyłączona. 
\end{itemize}
\section{Architektura systemu}
\subsection{Architektura modułu mobilnego}
Architektura oparta na zdarzeniach (Event-Driven Architecture, EDA) stanowi kluczowy element naszego projektu aplikacji mobilnej. Wybraliśmy tę architekturę ze względu na jej zdolność do efektywnego zarządzania komunikacją między różnymi modułami i~komponentami aplikacji, zwłaszcza w kontekście obsługi stanu i przetwarzania zdarzeń.

W ramach tej architektury, BLoC i Cubit pełnią rolę obsługiwaczy zdarzeń.
BLoC to jedno z narzędzi do zarządzania stanem w aplikacjach Flutter. Możemy go używać do obsługi wszystkich stanów, które chcemy kontrolować w naszych aplikacjach. Cubit to podzbiór wzorca projektowego BLoC, który upraszcza sposób zarządzania stanem aplikacji. W tym celu zastępuje użycie zdarzeń (używanych w BLoC) funkcjami, które odbudowują interfejs użytkownika poprzez emitowanie różnych stanów na strumieniu.

Cubit jest podobny do BLoC, ale nie posiada zdarzeń i polega na metodach do emitowania nowych stanów. Są one odpowiedzialne za nasłuchiwanie i przetwarzanie zdarzeń, które są generowane w różnych częściach aplikacji. Na przykład, BLoC lub Cubit ds. uwierzytelniania może nasłuchiwać zdarzeń takich jak ``zalogowanie użytkownika'' lub ``wylogowanie użytkownika'' i reagować poprzez zmianę stanu uwierzytelnienia. Na rysunku poniżej przedstawiono fragment kodu klasy typu Cubit odpowiedzialnej za logikę dotyczącą logowania i rejestrowania użytkowników. 

\begin{figure}[H]
        \begin{lstlisting}
class AuthCubit extends Cubit<AuthState> {
    final AuthService _repository;

    AuthCubit(this._repository) : super(InitState());

    Future<void> loginUser(LoginRequest loginRequest) async {
        emit(LoadingState());
        try {
            final response = await _repository.login(loginRequest);
            
            await SecureStorageService.write
                (key: 'token', value: response);

            emit(LoginSuccessState(response));
            
        } catch (e) {
            emit(ErrorState(e.toString()));
        }
    }
 ...
        \end{lstlisting}
    \caption{Fragment Cubita z funkcją logującą }
    \label{fig:pseudokod:listings}
\end{figure}

Zdarzenia są generowane w odpowiedzi na różne interakcje użytkownika oraz na operacje asynchroniczne. Przykłady to zdarzenia ``kliknięcia przycisku'' w interfejsie użytkownika, ``wysłania formularza'' lub ``zakończenia operacji pobierania danych z serwera''. Zdarzenia te są kluczowe dla przekazywania informacji o działaniach i stanach aplikacji.

Jednym z głównych celów EDA jest utrzymanie luźnego powiązania między różnymi komponentami naszej aplikacji. Oznacza to, że BLoC i Cubit nie muszą mieć wiedzy o~źródle generowania zdarzenia, co przyczynia się do modularności i skalowalności projektu. Nowe funkcje i modyfikacje istniejących funkcji mogą być wprowadzane bez konieczności naruszania istniejącej struktury.

Aplikacje Flutter często wymagają operacji asynchronicznych, takich jak komunikacja z serwerem lub dostęp do bazy danych. Dzięki architekturze opartej na zdarzeniach, te operacje asynchroniczne są inicjowane i obsługiwane poprzez generowanie i przetwarzanie zdarzeń. Jest to ważne dla zachowania spójności i zarządzania asynchronicznymi przepływami w aplikacji.

Architektura oparta na zdarzeniach umożliwia także wprowadzenie warstwy pośredniej, która może przechwytywać, przetwarzać i filtrować zdarzenia przed ich dostarczeniem do odpowiednich BLoC lub Cubit. To zapewnia dodatkową kontrolę nad przepływem zdarzeń i może być używane do wykonywania ogólnych operacji, takich jak logowanie lub uwierzytelnianie.

Wszystkie te elementy razem tworzą spójną i skalowalną architekturę, która umożliwia nam efektywne zarządzanie stanem i komunikacją w naszej aplikacji.

\subsection{Struktura plików}
\subsubsection{Aplikacja mobilna}

Poniżej znajdują się nazwy głównych folderów oraz opis plików jakie w sobie posiadają:
\begin{itemize}
    \item /api - znajdują się tam wszystkie modele związane z tworzeniem zapytań oraz odbieraniem danych z serwera. Każdy model request posiada metodę toJson(), która zamienia obiekt flutterowy na JSON'a, natomiast modele respons, posiadają metodę fromJson(), która zamienia JSON'a z serwera na obiekt flutterowy, który możemy wykorzystać w aplikacji.

    \item /constants - folder ten zawiera wszelkie stałe, które są używane w wielu miejscach aplikacji. Dla przykładu baseUrl który jest niezmienną częścią adresu url do połączenia z backendem.

    \item /cubit - zawiera pliki dotyczące zarządzania stanem aplikacji. Dzięki użyciu cubita zamiast czystego BLoCa nie posiadamy w nim plików związanych ze zdarzeniami ponieważ funkcjonalność zdarzeń przejęły funkcje znajdujące się już w cubitach. Poza cubitami, które zmieniają stany aplikacji oraz obsługują logikę, folder ten posiada również pliki stanów, które określają jakie zmienne posiadają konkretne stany aplikacji.

    \item /custom\_widgets - jest to zbiór ostylowanych widgetów przygotowanych do wielokrotnego użytku. W większości przypadków zmiana sprowadza się to do tego, że dany widget ma własności które posiadają wartości domyślne które możemy zmienić w zależności od potrzeb lub zostawić takimi jakimi są, lecz są również własności które należy podać.

    \item /extensions - są to pliki, które umożliwiają rozwijanie wbudowanych klas takich jak na przykład String o nowe metody które nie są domyślnie zawarte we frameworku.

    \item /helpers - są tu zawarte funkcje, które z uwagi na wielokrotne użycie w wielu miejscach naszej aplikacji, zostały przeniesione do osobnego folderu. Znajdują się tu dla przykładu funkcje wyświetlające snackbary lub formatujące datę zgodnie z ustawieniami użytkownika. 

    \item /l10n - jest to folder zawierający pliki .arb które są odpowiedzialne za przechowywanie tekstów znajdujących się w aplikacji. Dzięki zawarciu wszystkich tekstów tutaj, tłumaczenie aplikacji sprowadza się do dodania nowego pliku .arb zawierającego wszystkie teksty, oraz dodanie obsługiwanego tekstu do main.dart. 

    \item /pages - są tutaj wszystkie strony jakie posiadamy w aplikacji. są one przechowywane w osobnych folderach ponieważ każda ze stron jest rozdzielona na mniejsze widgety które z uwagi na swoje jednokrotne zastosowanie i brak uniwersalności nie możemy przechowywać w folderze /custom\_widgets. 

    \item /providers - jest to zbiór klas providerów używanych w aplikacji. Każdy plik posiada konstruktor, funkcję set oraz funkcje get.

    \item /services - znajdują się tutaj pliki odpowiedzialne za komunikację pomiędzy aplikacją a serwerem, jak i również komunikację wewnątrz aplikacji jak na przykład pobieranie danych GPS urządzenia czy dostęp do pamięci wewnętrznej urządzenia. 

\end{itemize}

\subsection{Komunikacja aplikacji mobilnej z serwerem}
Komunikacja aplikacji mobilnej z serwerem jest przeprowadzana za pomocą serwisów oraz cubitów. Cubity obsługują zdarzenia, które są wywoływane przez użytkownika. Obsługa zdarzeń w większości przypadków przebiega następująco:
\begin{itemize}
    \item Zamiana stanu na stan ładownia.
    \item Jeżeli jest to zdarzenie polegające na wysłaniu zapytania do serwera to teraz jest ono wykonywane.
    \item Przetworzenie informacji zwrotnych z serwera.
    \item Ustawienie stanu załadowanego zawierającego nowe dane.
\end{itemize}

Wysłanie zapytania tak jak to było wspomniane powyżej jest wykonywane przez serwis. Każdy serwis zawiera zestaw zapytań dotyczący jednej dziedziny takiej jak autoryzacja lub dane szczegółowe użytkownika. Każde zapytanie poza rejestracją oraz logowaniem wymaga posiadania tokenu. Token ten otrzymujemy podczas logowania i przechowujemy go w secured storage. Jest on pobierany z pamięci urządzenia za każdym razem gdy wykonujemy zapytanie. Odpowiedź z serwera jest sprawdzana i w zależności czy zapytanie powiodło się to wywoływana jest metoda fromJson z odpowiedniego modelu response lub wyświetlany jest komunikat w postaci snackbara.

\subsection{Użycie Providera}

Provider w aplikacji mobilnej jest drugim po BLoCu, systemem zarządzania stanem. Dzięki tej bibliotece zarządzanie zmiennymi globalnymi staje się dużo prostsze. Możemy dzięki temu odświeżyć aplikację, gdy taka zmienna została zmieniona w dowolnym miejscu naszej aplikacji. Działanie wygląda następująco:
\begin{itemize}
    \item Widgety klasy, w której chcemy zainicjalizować Providera, dodajemy jako dziecko widgetu, który znajduje się w bibliotece Provider, zwanym ChangeNotifierProvider. Widget ten potrzebuje klasy typu Provider, której obiekt tworzony jest podczas inicjalizacji. Klasa typu Provider to klasa, która posiada w sobie konstruktor, funkcję ustawiającą ``set'', funkcję, która zwraca zmienne oraz zmienne, które mają być dostępne w naszej aplikacji, a ich zmiana ma skutkować odświeżeniem strony. Na rysunkach poniżej przedstawione zostały fragmenty kodów odpowiedzialnych kolejno za implementację widgetu ChangeNotifierProvider oraz implementację widgetu Consumer.
    \begin{figure}[H]
        \begin{lstlisting}
        @override
        Widget build(BuildContext context) {
            return Scaffold(

              ...
              
              body: ChangeNotifierProvider(
                create: (_) => MetricSystemProvider(),
                child: ListView()

                ...
        \end{lstlisting}
    \caption{Implementacja widgetu ChangeNotifierProvider}
    \label{fig:pseudokod:listings}
    \end{figure}
    \begin{figure}[H]
        \begin{lstlisting}
        class MetricSystemProvider extends ChangeNotifier {
          late bool _isMetric;
          bool get isMetric => _isMetric;
        
          MetricSystemProvider() {
            _isMetric = false;
            getPreferences();
          }
        
          set isMetric(bool value) {
            _isMetric = value;
            AppSharedPreferences.saveMetricSystemPreference(value);
            notifyListeners();
          }
        
          getPreferences() async {
            _isMetric = await AppSharedPreferences.getMetricSystemPreference();
            notifyListeners();
          }
        }
        \end{lstlisting}
    \caption{Klasa typu Provider}
    \label{fig:pseudokod:listings}
    \end{figure}
    \item W miejscu, które ma odczytywać lub zapisywać zmienną klasy Provider, dodajemy do drzewa widget Consumer. Jest to kolejny widget, który jest nam dostarczany razem z biblioteką i służy do nasłuchiwania zmian, które następują w obiekcie klasy Provider. Gdy taka zmiana zostanie wykryta, powoduje ona przebudowę całego drzewa widgetów aż do Consumera, używając najnowszych danych.
    \begin{figure}[H]
        \begin{lstlisting}
        ...
        
        Consumer<MetricSystemProvider>(builder:
            (context, MetricSystemProvider metricNotifier, child) {
                return SwitchWidget()

                ...
        \end{lstlisting}
    \caption{Implementacja widgetu Consumer}
    \label{fig:pseudokod:listings}
    \end{figure}
\end{itemize}

Provider w aplikacji jest używany w celu:
\begin{itemize}
    \item Zmiany motywu kolorystycznego aplikacji: Zmiana motywu kolorystycznego następuje w podstronie ustawienia za pomocą przełącznika, który zapisuje jego stan w~pamięci wewnętrznej aplikacji. Aby poinformować, że użytkownik chce zmienić motyw, musielibyśmy widget po widgecie dotrzeć na sam początek drzewa i tam wykonać funkcję setState(). Dzięki użyciu Providera ChangeNotifier, sam wykryje zmianę wartości, której nasłuchuje, i odświeży stronę z prawidłowym motywem kolorystycznym. 
    \item Zmiana systemu metrycznego: W naszej aplikacji wykorzystujemy system metryczny. Mamy jednak również możliwość zmiany tego systemu na system imperialny. Użycie Providera powoduje prostą zmianę jednostek w innej gałęzi drzewa widgetów, bez konieczności przekazywania funkcji voidCallback().
\end{itemize}

\subsection{Powiadomienia}

Aplikacja mobilna posiada zaimplementowaną funkcjonalność lokalnych powiadomień. Powiadomienia dotyczą:
\begin{itemize}
    \item Poinformowaniu użytkownika, że znajduje się w pobliżu pocztówki która jest możliwa do zebrania. 
    \item Poinformowaniu użytkownika, że aplikacja aktualnie używa lokalizacji użytkownika w celu lokalizowania nowych pocztówek.
\end{itemize}
Do wykonywania lokalnych powiadomień wykorzystaliśmy bibliotekę ``flutter\_local\_notifications''. Aby powiadomienia mogły być wyświetlane, wymagane były odpowiednie zmiany w pliku AndroidManifest.xml, w którym należało dodać odpowiednie pozwolenia.
Powiadomienie o tym, że w pobliżu znajduje się pocztówka możliwa do zebrania, wykonywane jest po odpowiedzi z serwera. Serwer na podstawie naszej lokalizacji przysyła nam dwie listy:
\begin{itemize}
    \item Listę pocztówek możliwych do zebrania.
    \item Listę pocztówek w pobliżu, do których musimy jeszcze się zbliżyć, aby je zebrać.
\end{itemize}
Po każdym wykonanym zapytaniu, aplikacja zapamiętuje, o których pocztówkach już poinformowała użytkownika zapisując ich ID w pamięci lokalnej urządzenia, która jest resetowana po godzinie lub przy wyłączeniu opcji lokalizowania. Poniżej znajduje się fragment kodu odpowiedzialny za wykonywanie lokalnych powiadomień.
\begin{figure}[H]
        \begin{lstlisting}
        ...
        PostCoordinatesResponse response =
        await collectPostcardService.postCoordinates(coordinatesRequest);

        print(
            "Recived: ${response.postcardsCollected?.length}, and ${response.postcardsNearby?.length}");
    
        _cyclesCount += 1;
    
        final List<int> storedPostcardsNearbyIds =
            await AppSharedPreferences.getPostcardsNearbyIdList();
    
        List<int> newPostcardIds = (response.postcardsCollected
                ?.map((postcard) => postcard.id)
                .whereType<int>()
                .where((id) => !storedPostcardsNearbyIds.contains(id))
                .toList()) ??
            [];
    
        if (newPostcardIds.isNotEmpty) {
          NotificationService().showNotification(
              title: "New Postcard",
              body: "There are new postcards ready to collect!");
    
          storedPostcardsNearbyIds.addAll(newPostcardIds);
          await AppSharedPreferences.savePostcardsNearbyIdList(
              storedPostcardsNearbyIds);
        }
    
        if (_cyclesCount > 360) {
          _cyclesCount = 0;
          await AppSharedPreferences.savePostcardsNearbyIdList([]);
        }
        ...
        \end{lstlisting}
    \caption{Fragment funkcji odpowiedzialny za wykonywanie powiadomień}
    \label{fig:pseudokod:listings}
    \end{figure}
Sama operacja wykonywania powiadomienia jest zawarta w klasie NotificationService, która zawiera metodę showNotification.
\begin{figure}[H]
        \begin{lstlisting}
        ...
        Future showNotification({int id = 0, String? title, String? body, String? payload}) async {
            await initNotification();
            var notificationDetailsObj = await notificationDetails();
            return notificationsPlugin.show(id, title, body, notificationDetailsObj);
        }
        ...
        \end{lstlisting}
    \caption{Metoda showNotification}
    \label{fig:pseudokod:listings}
    \end{figure}

\subsection{Panel admina aplikacji mobilnej}

Aplikacja mobilna posiada dodatkową stronę do administrowania pocztówkami znajdującymi się w bazie danych. W celu otrzymania dostępu do tej strony, administrator musi nadać rolę ADMIN do konta, na którym strona ma być dostępna. Po zalogowaniu na odpowiednie konto, użytkownik powinien mieć dostęp do ``Admin Panel'' z poziomu menu bocznego. 
Na tej stronie użytkownik posiada możliwość edycji danych pocztówki lub dodanie nowej. W celu obsługi dodatkowych funkcjonalności admina użyty został Provider, który umożliwia nam na sprawdzenie w dowolnym miejscu aplikacji przy użyciu widgetu Consumer czy zalogowany użytkownik posiada rolę USER czy ADMIN i na podstawie tego wyświetlać odpowiednie podstrony i dane.

\section{Instrukcja obsługi}

\subsection{Rejestracja i logowanie}
Aby rozpocząć używanie aplikacji, użytkownik musi założyć konto na poniższej stronie.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/rejestracja.png}
    \caption{Strona do rejestracji użytkownika}
\end{figure}

Na stronie znajdują się cztery pola których wypełnienie jest wymagane. Symbol oka przy hasłach powoduje odsłonięcie hasła. Na dole strony znajduje się przycisk ``Sign in'' który przenosi użytkownika na stronę logowania. 
Po udanej rejestracji na dole ekranu pojawi się informacja na zielonym tle informująca o utworzeniu konta a użytkownik zostanie przekierowany na stronę logowania która wygląda w następujący sposób 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/logowanie.png}
    \caption{Strona do logowania użytkownika}
\end{figure}

Na stronie logowania również posiadamy przycisk odsłaniający hasło a przycisk ``Sign up'' przenosi użytkownika do strony z rejestracją. 

\subsection{Nawigacja po aplikacji}
Nawigacja po aplikacji została wykonana w postaci szuflady. Każdy dział aplikacji posiada odpowiednią podstronę. Dodatkowo administrator posiada podstronę do zarządzania pocztówkami znajdującymi się w bazie danych oraz każdy typ użytkownika posiada przycisk wylogowujący na dole szuflady.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/szuflada.png}
    \caption{Szuflada służąca do nawigacji}
\end{figure}

\subsection{Edycja konta i informacji}
W aplikacji możemy zobaczyć jak inni widzą nasz profil wchodząc na stronę ``Profile page'' która wygląda następująco:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/profil_bez_info.png}
    \caption{Strona z profilem użytkownika bez informacji}
\end{figure}

Na powyższym zrzucie ekranu widzimy profil który posiada dwie ulubione pocztówki ale nie ma jeszcze wprowadzonych danych oraz zdjęć. Aby takowe wprowadzić należy przejść do strony edycji profilu używając przycisku ``Edit profile'' znajdującego się po prawej stronie. Użytkownik zostanie wtedy przeniesiony do strony edycji gdzie może wprowadzić swoje dane osobowe. Każda z rubryk jest nieobowiązkowa. Użytkownik sam może wybrać jakie dane chce aby się wyświetlały na jego profilu. Poniżej znajdują się zrzuty ekranu obrazujące proces wprowadzania informacji do profilu.

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/edycja_profilu_bez_danych.png}
    \caption{Edycja profilu bez wprowadzonych danych}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/edycja_profilu_z_danymi.png}
    \caption{Edycja profilu z wprowadzonymi danymi}
  \end{minipage}
\end{figure}

Po wprowadzeniu danych nasz profil prezentuje się następująco.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/profil_z_info.png}
    \caption{Strona z profilem użytkownika bez informacji}
\end{figure}

\subsection{Kolekcja}
Kolekcja to dział w którym możemy zobaczyć wszystkie pocztówki które kiedykolwiek odebraliśmy nawet jeżeli pocztówkę z tego miejsca komuś wysłaliśmy. Pierwsza zakładka to nasza kolekcja która wygląda następująco. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/obrazki_nasze.png}
    \caption{Widok zakładki z naszą kolekcją}
\end{figure}

Druga zakładka to wszystkie pocztówki które można zebrać. Jeżeli dana pocztówka znajduje się w naszej kolekcji to jest ona kolorowa, jeżeli danej pocztówki jeszcze nie uzyskaliśmy, będzie ona czarno biała. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/obrazki_wszystkie.png}
    \caption{Widok zakładki z naszą kolekcją}
\end{figure}

Na obu zakładkach możemy wyszukiwać daną pocztówkę po nazwie, filtrować pocztówki oraz je sortować. 

\subsection{Pocztówki}
Pocztówki to podstrona która zawiera te pocztówki, które zebraliśmy i możemy wysłać jak i również te, które otrzymaliśmy od innych użytkowników. W pierwszej zakładce znajdują się pocztówki które możemy komuś wysłać. Możemy te pocztówki tak samo jak w przypadku kolekcji filtrować, wyszukiwać i sortować. Po wciśnięciu danej pocztówki pojawia się dodatkowe okienko ukazujące więcej szczegółów dotyczące danej pocztówki. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/pocztowki.png}
    \caption{Zawartość zakładki z pocztówkami do wysłania}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/pocztowki_podglad.png}
    \caption{Podgląd pocztówki do wysłania}
  \end{minipage}
\end{figure}

Druga zakładka zawiera pocztówki, które dostaliśmy od innych użytkowników. Zawartość jest podobna jak w pierwszej zakładce z tą różnicą, że pocztówki które są naszymi ulubionymi posiadają złotą ramkę. Różnice znajdują się również w podglądzie. Zamiast przycisku ``Send'' mamy przycisk serduszka, dodający daną pocztówkę do naszych ulubionych.  W podglądzie mamy również tytuł oraz treść którą ktoś wraz z daną pocztówką nam wysłał.

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/pocztówki_odebrane.png}
    \caption{Zawartość zakładki z odebranymi pocztówkami}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/pocztówki_odebrane_podglad.png}
    \caption{Podgląd odebranej pocztówki\\}
  \end{minipage}
\end{figure}

\subsection{Odbieranie pocztówek}

Odbieranie pocztówek następuje na podstronie ``Collect''. Strona posiada dwie listy: pierwsza pokazuje nam pocztówki znajdujące się w zasięgu zebrania, druga natomiast pocztówki znajdujące się w zasięgu powiadamiania, który został ustawiony w ustawieniach. Gdy wciśniemy przycisk ``Redeem postcard'' na pocztówce z pierwszej listy, do naszej kolekcji dodana zostanie pocztówka dla nas oraz kopia do wysłania naszemu znajomemu. Gdy wciśniemy pocztówkę znajdującą się w drugiej liście, zostaniemy przeniesieni do strony pokazującej nam dokładne koordynaty pocztówki, jak i przycisk, który przeniesie nas do strony Google Maps z ustawioną już pocztówką do danej lokalizacji.

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/odbieranie pocztówek.png}
    \caption{Podstrona do odbierania pocztówek}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/lokalizownaie_pocztówki.png}
    \caption{Podstrona do lokalizowania pocztówki}
  \end{minipage}
\end{figure}

Aplikacja posiada również mechanizm powiadamiania użytkownika o tym, że znajduje się w pobliżu pocztówki do odebrania. Gdy znajdujemy się w jej zasięgu zostaje wysłane lokalne powiadomienie. Jest one wysyłane tylko raz na godzinę lub do momentu ponownego włączenia lokalizowania pocztówek.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/powiadomienie.png}
    \caption{Powiadomienie o nowej pocztówce}
\end{figure}

Podstrona do odbioru pocztówek posiada również wersję gdy użytkownik nie włączył lokalizowania pocztówek jak i również wersje gdy lokalizacja jest w telefonie całkowicie wyłączona.

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/lokalizacja_pocztowek_wylaczana.png}
    \caption{Wersja podstrony gdy lokalizowanie pocztówek jest wyłączone}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/lokalizacja_w_tel_wylaczana.png}
    \caption{Wersja podstrony gdy lokalizacja w telefonie jest wyłączona}
  \end{minipage}
\end{figure}

\subsection{Ustawienia}
W ustawieniach, użytkownik może dostosować aplikację do swoich potrzeb jak i zarządzać pewnymi jej funkcjami. 
Ustawienia umożliwiają:
\begin{itemize}
    \item Zmieniać motyw na jasny lub ciemny
    \item Włączać i wyłączać lokalizowanie pocztówek
    \item Włączać i wyłączać powiadomienia
    \item Zmieniać zasięg powiadamiania użytkownika o pocztówkach w pobliżu
    \item Zmieniać format daty
    \item Zmieniać typ jednostek
    \item Przeczytane zasad korzystania z aplikacji
    \item Usunięcie konta
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/ustawienia.png}
    \caption{Podstrona z ustawieniami}
\end{figure}

\subsection{Panel administratora}
Użytkownicy ze statusem administratora mają dostęp do dodatkowej zakładki w której mogą edytować istniejące już pocztówki jak i również z poziomu aplikacji dodawać nowe. Przeglądanie pocztówek w panelu admina jest wykonane podobnie do przeglądania pocztówek zwykłego użytkownika.

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/admin.png}
    \caption{Podstrona do zarządzania pocztówkami}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/admin_edit.png}
    \caption{Podstrona do edycji i dodawania nowych pocztówek}
  \end{minipage}
\end{figure}

\subsection{Znajomi}
Strona która służy do zdobywania nowych znajomości jest podzielona na 3 zakładki. W pierwszej zakładce znajdują się użytkownicy których śledzimy, w drugiej zakładce znajdują się użytkownicy którzy nas śledzą, natomiast w trzeciej zakładce znajdują się wszyscy użytkownicy. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.30\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/followani.png}
    \caption{Zakładka ze śledzonymi użytkownikami\\}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.30\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/followingby.png}
    \caption{Zakładka z użytkownikami którzy nas śledzą}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.30\textwidth}
    \includegraphics[width=\textwidth]{mobile_ss/wszyscyUzytkownicy.png}
    \caption{Zakładka ze wszystkimi użytkownikami\\}
  \end{minipage}
\end{figure}

Po wciśnięciu na dowolnej zakładce karty z użytkownikiem zostaniemy przekierowani do strony ze szczegółami danego użytkownika na której również znajduję się przycisk który służy do śledzenia lub zrezygnowania ze śledzenia danego użytkownika. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/friend.png}
    \caption{Strona użytkownika}
\end{figure}

\subsection{Wysyłanie pocztówek}
Aby wysłać pocztówkę należy udać się na stronę z pocztówkami, tam po wybraniu odpowiedniej pocztówki na podglądzie wciskamy ``Send'' co przekieruje nas na podstronę do wysyłania pocztówek. Tam, możemy dodać tytuł oraz opis do pocztówki a nstępnie wybrać użytkownika do którego chcemy daną pocztówkę wysłać. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{mobile_ss/wysyłanie.png}
    \caption{Strona do wysyłania pocztówek}
\end{figure}

% ==========================================================================================
% ==========================================================================================
% ===================== BACKEND  ==========================================================================================

\chapter{Aplikacja serwerowa}
\section{Technologia}
Podczas wyboru technologii do realizacji aplikacji backendowej, kierowaliśmy się najnowszymi oraz najszybszymi rozwiązaniami. Docelowa platforma powinna być stale utrzymywana, dzięki czemu aplikacja mogłaby być z łatwością rozwijana w przyszłości. Popularne platformy cieszą się dużym zaangażowaniem społeczności, co umożliwia łatwiejsze rozwiązywanie napotkanych problemów. Ponadto możemy spojrzeć na gotowe rozwiązania, z których możemy czerpać dobre praktyki architektoniczne oraz rozwiązania. Wybór padł na technologie Microsoft, czyli język C\# oraz framework .NET 7.  

\subsection{Język C\#}
Język C\# jest silnie typowany oraz obiektowy, stworzony oraz rozwijany przez firmę Microsoft. Jest on częścią frameworka .NET, który umożliwia tworzenie aplikacji desktopowych, mobilnych, webowych.  Język C\# historycznie wzorowany jest na języku Java, czerpał z niego np. składnie, sposób działania. Dzięki byciu młodszą technologią wprowadza oraz doskonali wiele nowych rozwiązań.  
Do najważniejszych cech języka C\# można zaliczyć m.in.: 
\begin{itemize}
    \item Obiektowość - cała logika oraz sposób działania oparty jest na klasach. Podstawową klasą jest klasa ‘Object’ znajdująca się w przestrzeni nazw ‘System’. Każda inna dostępna klasa dziedziczy po niej. Dzięki czemu każda klasa w C\# posiada takie metody jak np. Equals(Object), GetType(), ToString(), oraz parę innych. 
    \item Zarządzanie pamięcią - język C\# podobnie jak Java posiada mechanizm Garbage Collector, dzięki któremu program automatycznie usuwa obiekty, które są już nieużywane. Dzięki takiemu rozwiązaniu programista nie musi dbać o ręczne zarządzanie pamięcią, co pozwala uniknąć problemów z jej wyciekiem. 
    \item LINQ – kwerendy Language Integrated Query umożliwiają pracę na obiektach, listach obiektów. Podobnie jak w języku SQL możemy pisać zapytania zwracające odpowiednie dane.
    \item Asynchroniczność - C\# pozwala na wykonywanie kodu w sposób wielowątkowy. Zawiera mechanizmy pozwalające wykonywać kod w sposób asynchroniczny, co jest istotne w przypadku nowoszesnych aplikacji webowych.
\end{itemize}

\subsection{Platforma .NET}
Platforma .NET stworzona przez Microsoft jest przeznaczona do tworzenia aplikacji na różne platformy. Obsługuje ona wiele języków programowania takich jak: C\#, F\#, Visual Basic. Sposób działania jest następujący. Docelowy język, w naszym przypadku to C\#, jest kompilowany przez kompilator do języka Common Intermediate Language (CIL). Następnie przechodzi przez Common Language Runtime (CLR). CLR to środowisko uruchomieniowe, które podczas uruchamiania aplikacji kompiluje kod przez just-in-time compiler (JIT). W ostatnim kroku kod tłumaczony jest na język maszynowy. Proces ten schematycznie przedstawiony został na rysunku 6.1.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{compiler.png}
    \caption{Przepływ kompilowanego kodu \href{https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet-framework}{https://dotnet.microsoft.com}.}
    \label{Kompilator}
\end{figure}

\subsection{Biblioteki}
W niniejszej sekcji zaprezentowano zastosowane w projekcie biblioteki wraz z ich krótkim opisem.
\subsubsection{Biblioteka główna}
    \begin{itemize}
        \item \textbf{ASP.NET Core 7.0} -- platforma programistyczna do tworzenia aplikacji.
    \end{itemize}
\subsubsection{Biblioteki pomocnicze}
    \begin{itemize}
        \item \textbf{Microsoft.EntityFrameworkCore} -- ORM (Object-Relational Mapping) biblioteka służąca do mapowania obiektami z bazy danych.
        \item \textbf{Microsoft.EntityFrameworkCore.Relational} -- dostarcza funkcjonalności, które usprawniają tworzenie relacji bazy danych.
        \item \textbf{Microsoft.EntityFrameworkCore.Design} -- zawiera logikę design-time. Są to narzędzia do projektowania baz danych oraz projektowania modelu danych.
        \item \textbf{Microsoft.EntityFrameworkCore.SqlServer} -- integracja frameworku z silnikiem bazy danych opartych na SQL Server.
        \item \textbf{Microsoft.EntityFrameworkCore.Tools} -- narzędzie do tworzenia migracji.
        \item \textbf{Microsoft.AspNetCore.Authentication.JwtBearer} -- implementacja funkcji dostarczających obsługę uwierzytelniania z wykorzystaniem tokenów JWT (JSON Web Token).
        \item \textbf{Swashbuckle.AspNetCore} -- dostęp do narzędzia Swagger, umożliwiającego generowanie dokumentacji na podstawie dostępnych w aplikacji endpointów.
        \item \textbf{Swashbuckle.AspNetCore.Annotations} -- wsparcie dla Swaggera, w postaci adnotacji.
        \item \textbf{AutoMapper} -– biblioteka służąca do mapowania obiektów znajdujących się pomiędzy różnymi warstwami.
        \item \textbf{AutoMapper.Extensions.Microsoft.DependencyInjection} -- rozszerzenie funkcji Automappera, o wstrzykiwanie zależności.
        \item \textbf{Microsoft.AspNetCore.Http} -- obsługa żądań HTTP.
        \item \textbf{Microsoft.Extensions.DependencyInjection.Abstractions} -- interfejsy dla systemu wstrzykiwania zależności.
        \item \textbf{Microsoft.Extensions.Identity.Core} -- biblioteka umożliwia dodawanie funkcji logowania do aplikacji.
        \item \textbf{Microsoft.NET.Test.Sdk}  -- narzędzia do tworzenia testów jednostkowych.
        \item \textbf{Moq} -- wykorzystanie w testach jednostkowych atrap pewnych funkcjonalności, w celu izolowania faktycznych implementacji od testów.
        \item \textbf{Xunit} -- framework do testów jednostkowych.
        \item \textbf{Unit.runner.visualstudio} -- program służący do uruchamiania testów jednostkowych.
    \end{itemize}

\section{Architektura}
W projekcie zastosowaliśmy architekturę Onion Architecture (Cebulowa Architektura). Wymusza ona na nas konkretne podejście do tworzenia oprogramowania. Dzięki ścisłym regułom oraz zasadom, tworzona aplikacja zawiera uporządkowany kod, podzielony na mniejsze projekty a dalej klasy. Aplikacja składa się z warstw pomiędzy, którymi występują odpowiednie zależności. Stąd pochodzi nazwa Onion Architecture.

\subsection{Onion Architecture}
\begin{itemize}
    \item \textbf{Warstwa Domain} -- nie posiada żadnej zależności, znajduje się w samym centrum warstw. Warstwa ta tworzy modele obiektów użytych później w bazie danych. Każdy z Modeli konfigurujemy, ustawiamy typ danych, jego właściwości. Jest również odpowiedzialna za logikę biznesową. 
    \item \textbf{Warstwa Application} -- posiada zależność do warstwy Domain. Warstwa ta posiada implementacje serwisów, czerpie dane z wartwy wewnętrznej, czyli Domain, a następnie przetwarza odpowiednio dane i przekazuje do warstwy zewnętrznej, czyli Infrastructure. 
    \item \textbf{Warstwa Infrastructure} -- posiada zależność do warstwy Application. Warstwa odpowiada za komunikację z bazą danych, wymienia się danymi z warstwą Application. 
    \item \textbf{Warstwa WebAPI} -- posiada zależność do warstwy Application oraz Infrastructure. Jej głównym celem jest obsługa zdarzeń z użytkownikiem oraz przekazywanie żądanych danych. Dane te są obsługiwane poprzez wykorzystanie protokołu HTTP. 
    \item \textbf{Warstwa Tests} -- posiada zależność do warstwy Application, dzięki czemu posiadamy możliwość wywoływania funkcjonalności z aplikacji. 
\end{itemize}

W celu dobrej komunikacji między poszczególnymi warstwami wykorzystujemy mechanizm Dependency Injection. Dependency Injection, inaczej wstrzykiwanie zależności pozwala na odpowiednie udostępnianie oraz zarządzanie zależnościami jakie występują pomiędzy warstwami w solucji. 

\subsection{Struktura plików}
Struktura plików w projekcie jest ściśle związana z zastosowaną architekturą Onion Architecture.
Cała solucja podzielona jest na parę projektów. Każdy z nich pełni odpowiednią rolę w swojej warstwie.  

\begin{enumerate}
    \item \textbf{WebAPI} \begin{itemize}
        \item \textbf{/Controllers} -- posiada implementacje wszystkich kontrolerów.
        \item \textbf{/Installers} -- znajdują się w nim wszystkie potrzebne instalacje zależności takie jak Cors, Baza danych, Cache, Uwierzytelnianie, MVC, Swagger. Każda zależność przydzielona jest do konkretnej klasy, która implementuje interfejs IInstaller. Podczas uruchomienia aplikacji wszystkie zależności, które implementują interfejs IInstaller, są odpowiednio wcześniej uruchomione przed startem web API. 
        \item \textbf{/Properties} -- zawiera plik, który definiuje właściwości uruchamiania aplikacji, takie jak adres Url, port, środowisko Swagger.
        \item \textbf{Program.cs} -- główny plik uruchomieniowy aplikacji serwerowej.
        \item \textbf{WebAPI.csproj} -- zawiera listę zewnętrznych bibliotek, zależności pomiędzy projektami oraz ustawienia projektu.
        \item \textbf{Appsettings.json} -- plik konfiguracji aplikacji.
        \item \textbf{Appsettings.development.json} -- plik konfiguracji aplikacji dla środowiska deweloperskiego.
    \end{itemize}

    \item \textbf{Application} \begin{itemize}
        \item \textbf{/Constants} -- stałe wartości, użyte w aplikacji.
        \item \textbf{/Dto} -- modele Data Transfer Object (DTO) - obiekty które zawierają konkretne pola, które chcemy przekazać dalej.
        \item \textbf{/Exceptions} -- spersonalizowane wyjątki.
        \item \textbf{/Helpers} -- pomocnicze funkcje.
        \item \textbf{/Interfaces} -- interfejsy do serwisów.
        \item \textbf{/Mappings} -- podzielony jest na konfiguracje Automappera wraz z obiektami zmapowanymi, oraz na folder /Manual, który zawiera manualnie zmapowane obiekty.
        \item \textbf{/Requests} -- obiekty dla żądania.
        \item \textbf{/Response} -- obiekty jako odpowiedź z endpointu.
        \item \textbf{/Services} -- implementacje serwisów.
        \item \textbf{/Validators} -- walidacja wybranych funkcjonalności z serwisu.
        \item \textbf{Application.csproj} -- zawiera listę zewnętrznych bibliotek, zależności pomiędzy projektami oraz ustawienia projektu.
        \item \textbf{DependencyInjection.cs} -- dodaje usługi o określonym typie w serviceType oraz wstrzykuje zależności.
    \end{itemize}

    \item \textbf{Domain} \begin{itemize}
        \item \textbf{/Configurations } -- konfiguracja dla obiektów bazy danych, taka jak: wymagane pola, typy danych.
        \item \textbf{/Entities} -- modele, które są odzwierciedleniem bazy danych.
        \item \textbf{/Enums} -- obiekty typu Enum.
        \item \textbf{/Interfaces} -- interfejsy dla repozytorium.
        \item \textbf{/Models} -- obiekty odpowiedzialne za przekazanie danych z filtrowania oraz paginacji z warstwy Domain do warstwy Infrastructure.
        \item \textbf{Domain.csproj} -- zawiera listę zewnętrznych bibliotek, zależności pomiędzy projektami oraz ustawienia projektu.
    \end{itemize}

    \item \textbf{Infrastructure} \begin{itemize}
        \item \textbf{/Data} -- konfiguruje dostęp do bazdy danych, implementuje ustawienia uwierzytelniania, zawiera Data Seeder, który wprowadza dane testowe do bazy danych.
        \item \textbf{/Migrations} -- lista plików migracyjnych.
        \item \textbf{/Repositories} -- lista repozytoriów aplikacji, wraz z generycznym repozytorium ‘Repository.cs’, po którym dziedziczy każde pozostałe repozytorium. Generyczne repozytorium posiada zaimplementowane podstawowe operacje CRUD.
        \item \textbf{DependencyInjection.cs} -- dodaje usługi o określonym typie w serviceType oraz wstrzykuje zależności.
        \item \textbf{Infrastructure.csproj} -- zawiera listę zewnętrznych bibliotek, zależności pomiędzy projektami oraz ustawienia projektu.
    \end{itemize}

    \item \textbf{Tests} \begin{itemize}
        \item \textbf{/Usings.cs} -- zawiera importy używanych zasobów.
        \item \textbf{Tests.csproj} -- zawiera listę zewnętrznych bibliotek, zależności pomiędzy projektami oraz ustawienia projektu.
        \item \textbf{*Tests.cs} -- są to konkretne implementacje testów jednostkowych, odpowiednie dla każdego repozytorium.
    \end{itemize}
\end{enumerate}

\subsection{Silnik bazy danych}
MSSQL, czyli kolejne rozwiązanie firmy Microsoft. Jest to system zarządzania relacyjną bazą danych. Szczególnie popularny i łączony z innymi rozwiązaniami Microsoftu, często łączony z aplikacjami .NETowymi. MSSQL jak każda relacyjna baza danych przechowuje informacje w tabelach, która składa się z wierszy oraz kolumn. Silnik pozwala nam na dowolną manipulacją danymi. Jest to rozwiązanie bezpieczne, umożliwia szyfrowanie danych. W połączeniu z systemem operacyjnym Windows mamy możliwość uwierzytelniania poprzez zintegrowany system. Największą zaletą, w porównaniu z konkurencyjnymi rozwiązaniami bazodanowymi, jest udostępnienie języka T-SQL na potrzeby MSSQL.

T-SQL, od transakcyjny SQL, to rozszerzenie języka SQL o znane z języków programowania mechanizmy takie jak: pętle, instrukcje warunkowe, zmienne. Dzięki temu rozszerzeniu tworzenie procedur oraz wyzwalaczy (ang. trigger) daje o wiele większe możliwości. Rozszerzenie pozwala przerzucić część funkcjonalności aplikacji backendowej na silnik bazy danych. Przydatne podczas implementacji funkcjonalności opartych na zmiany rekordów w bazie. Tworzenie wyzwalaczy, czyli funkcji wywołujących się automatycznie na bazie po spełnieniu konkretnego warunku, pozwala na uniknięcie niektórych błędów.

Do obsługi oraz podglądu bazy danych wykorzystane zostało narzędzie SQL Server Management Studio. Jest to zintegrowane środowisko zawierające wiele przydatnych funkcjonalności. 

\subsection{Modele}
Na poniższym rysunku 6.2 przedstawiony został schemat bazy danych wraz z relacjami. Do poprawnego działania aplikacji backendowej wymagana jest dobrze zaprojektowana i zaimplementowana baza danych. To ona przechowuje wszystkie informacje o użytkownikach, pocztówkach, posiadanych danych i całej reszcie. Na zaprezentowanym rysunku widoczne są wszystkie dostępne relacje. Przykładem relacji wiele do wielu może być połączenie tabeli User z tabelą Postcards poprzez tabelę pośredniczącą, czyli UserPostcards. Przykładem relacji jeden do jednego jest User z UserDetails. Relacja jeden do wielu zaprezentowana jest w PostcardData oraz Postcard. Znaczy to tyle, iż jeden rekord z tabeli PostcardData może występować w wielu rekordach w tabeli Postcard.

Najważniejszymi składowymi bazy danych są: User oraz Postcards. Jest to trzon naszej bazy, od których rozgałęziają się pozostałe relacje. Tabela User przechowuje podstawowe informacje o użytkowniku. Ma bezpośrednią relację jeden do jednego do UserStats, czyli statystyk użytkownika, UserDetails, czyli informacji szczegółowych, Address, czyli adresu użytkownika. Ponadto tabela User posiada relację wiele to wielu z tabelą UserFriends, ponieważ relacja ta odpowiada za posiadanie listy osób obserwujących oraz obserwowanych.

Tabela Postcards zbiera dane, które w połączeniu z tabelami: UserPostcards, FavouritePostcards, PostcardsCollection, PostcardData tworzą wspólną całość. Odpowiedzialna jest ona za zbieranie danych o posiadanych przez użytkownika pocztówkach - ich dostępności, pocztówkach ulubionych, odebranych i wysłanych.

Tabela \_\_EFMigrationsHistory zawiera historię o wykonanych migracjach przy użyciu biblioteki EntityFramework. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{diagram1.png}
    \caption{Diagram UML}
    \label{Kompilator}
\end{figure}

\section{Specyfikacja wewnętrzna}
Głównym plikiem uruchomieniowym aplikacji backendowej jest plik WebAPI/Program.cs. To właśnie w tym pliku definiujemy m.in. DataSeeder, Swaggera, użycie kontrolerów, mechanizmu uwierzytelniania oraz instalacji. Wykorzystując klasę WebApplicationBuilder tworzymy builder na podstawie, którego budowana jest aplikacja serwerowa. W celu usprawnienia budowania oraz tworzenia projektu zaimplementowaliśmy abstrakcyjny poziom instalacji zależności wraz z metodą instalującą InstallServicesInAssembly(). Abstrakcja ta polega na implementacji metody InstallService() w interfejsie IInstaller. W ten sposób zaimplementowane zostały instalacje metod potrzebnych dla: Cors, Swaggera, Cache, Authentication, MVC, Db. Zastosowanie tego rozwiązania pozwala utrzymać porządek w kodzie, zwłaszcza w tak kluczowym segmencie projektu. 

Definicje REST API warto rozpocząć od zdefiniowania czym jest samo API.  
API (Application Programming Interface), czyli interfejs programistyczny aplikacji jest opisem zasada, w jaki programy komunikują się między sobą. API możemy wyobrazić sobie jako most łączący dwa brzegi, przez który poruszają się samochody, czyli w tym przypadku nasze dane. Gdyby ten most nie istniał to komunikacja lądowa pomiędzy dwoma brzegami byłaby niemożliwa. Tak samo jest z API, które jest kluczowe do działania programu.  

REST (Representational State Transfer) API – styl architektoniczny, który opisuje w jaki sposób tworzony ma być rozproszony system. REST API zawiera w sobie sześć reguł projektowania: 
\begin{enumerate}
    \item \textbf{Jednolity interfejs} -- zapytania spełniają reguły formatowania API.
    \item \textbf{Rozdzielenie klient-serwer} -- klient oraz serwer to osobne aplikacje. Klient posiada informację o nazwie zasobu i w razie potrzeby pobiera ją z serwera. Natomiast serwer nie może ingerować w klienta. 
    \item \textbf{Bezstanowość} -- serwer nie musi przechowywać informacji o żądaniu.
    \item \textbf{Buforowość} -- mechanizm, który wymusza implementację cachu. Jeżeli dany zasób jest w krótkim czasie wywoływany kilkukrotnie to powinien być on zapisany w pamięci podręcznej. 
    \item \textbf{Warstwowa architektura systemu} -- końcowy klient nie musi posiadać wiedzy czy zasoby, o które prosi znajdują się na bezpośrednio pytanym serwerze, czy też na innym. Serwer może pełnić funkcję pośrednika pomiędzy zasobami dostępnymi w bazie danych a w bazach danych zewnętrznych dostawców. 
    \item \textbf{Kod na żądanie} -- klient może żądać wykonania kodu.
\end{enumerate}

Protokołem komunikacyjnym, który pomaga spełnić wymagania REST API jest HTTP. Protokół posiada metody, które umożliwiają pozyskanie jak i przesyłanie informacji. Metoda GET służy do pobierania zasobów, zwyczajowo nie zawiera elementu body. Metoda POST tworzy nowe zasoby, Metoda PUT może być wykorzystana do zaktualizowania zawartości. Metoda DELETE służy do usuwania zasobów.  

Kody odpowiedzi HTTP możemy podzielić na pięć kategorii: 
\begin{enumerate}
    \item \textbf{Grupa informacyjna}. Przedział: 100 – 199.
    \item \textbf{Grupa potwierdzenia sukcesu}. Przedział: 200 – 299.
    \item \textbf{Grupa przekierowania}. Przedział: 300 – 399.
    \item \textbf{Grupa błędu po stronie klienta}. Przedział: 400 – 499.
    \item \textbf{Grupa błędu po stronie serwera}. Przedział: 500 – 599.
\end{enumerate}

\subsection{Kontroler}
Aplikacja zawiera kontrolery w projekcie WebAPI. Każdej tabeli w bazie danych odpowiada jeden kontroler. Kontroler to punkt dostępu dla klienta, zawiera on endpointy wraz z różnymi metodami CRUD. Odpowiedzialny za wymianę danych z użytkownikiem końcowym. To on dzięki użyciu protokołu HTTPS oraz zasad RESTAPI dostarcza klientowi zasoby. W skład kontrolera wchodzą metody CRUD, czyli metody odpowiedzialne za tworzenie, czytanie, aktualizacje oraz usuwanie danych. Dostęp do każdego endpointu może być dodatkowo ograniczony poprzez uwierzytelnianie i/lub autoryzację. Endpointy zawierają informację o ścieżce dostępu. Po otrzymaniu żądania kontroler deleguje dalsze działanie do serwisów aplikacji, które to odpowiadają za realizację logiki aplikacji oraz zwrócenie danych do kontrolera. 

\subsection{Serwis}
Serwis odpowiada ze przetworzenie danych otrzymanych przez kontroler, a następnie zwracanie rezultatu. Jeśli jest taka potrzeba serwis może komunikować się z innymi serwisami lub zewnętrznymi usługami. W razie potrzeby działania na bazie danych serwis wykorzystuje metody napisane w repozytoriach.  

\subsection{Repozytorium}
Klasy odpowiedzialne za bezpośrednią komunikację serwera z bazą danych. To za jego pomocą pobieramy oraz zmieniamy dane w bazie. Dostęp do repozytorium powinny mieć jedynie serwisy, przy założeniu ze korzystamy z architektury Onion Architecture oraz, że chcemy odpowiednio zabezpieczyć warstwy. Repozytoria wykonują podstawowe operacje CRUD lub bardziej złożone zapytania. Elementarne operacje takie jak tworzenie nowego rekordu, jego zmiana, usunięcie lub pobranie go możemy wyabstrahować do formy generycznych metod. 

\subsection{Generyczne repozytorium}
Generyczne repozytorium zawiera implementacje najprostszych metod CRUD. Umożliwia to w bardzo szybki sposób na implementację podstawowych funkcjonalności w aplikacji. Dodatkowo pozbywamy się zbędnych powtórzeń kodu, ponieważ operacje CRUD w większości przypadków są powtarzalne. W naszej aplikacji stworzyliśmy podstawową klasę Repository, od której to pozostałe repozytoria dziedziczą. Repository przyjmuje jako argument generyczny model dla tabeli, na której chcemy wykonywać operacje. Przez takie rozwiązanie generyczne metody mogą operować jedynie na jednej tabeli w tym samym czasie. W razie utworzenia bardziej zaawansowanych operacji poza istniejącą implementacją możemy wdrożyć dodatkowe metody. Przykładem mogą być operacje na bazie na wielu tabelach. 

\subsection{Migracje}
Entityframework Core dostarcza narzędzi do tworzenia migracji bazy danych.  

W projekcie wykorzystaliśmy podejście Model-First. Polega ono na stworzeniu encji oraz relacji, a następnie na ich podstawie EFCore generuje zapytania do bazy danych. Podejście takie stosowane jest zazwyczaj w przypadku, kiedy nie posiadamy jeszcze istniejącej bazy danych. Podejściem odwrotnym jest podejście Database-First. W tym przypadku to modele, relacje oraz mapowania są tworzone na podstawie istniejącej bazy danych. 

Aby utworzyć migrację wykorzystujemy polecenie Add-Migration <Nazwa>. Dzięki niemu tworzone są dwa pliki. W skład ich nazw wchodzi rok, miesiąc, dzień, godzina wykonania migracji oraz podana przez nas nazwa <Nazwa>. Dzięki zastosowanej składni rozwiązuje się kilka problemów. Po pierwsze taka nazwa jest jednoznacznie zidentyfikowana z konkretnymi zmianami. Po drugie dzięki formatowi daty, aplikacja wie w jakiej kolejności wywołać migrację, dzięki czemu unikniemy problemu z niepoprawną kolejnością ich wywoływania. 
Zawartość pliku migracji.cs to klasa zawierająca metody: Up() oraz Down(). Metoda Up() tworzy tabele, określa kolumny oraz relacje. Definiuje klucze główne oraz obce. Metoda Down() definiuje operację, które należy wykonać, aby cofnąć zmiany z metody Up(). Przydatne w razie pomyłki oraz potrzeby cofnięcia zmian.
Natomiast plik migracja.Designer.cs definiuje encje, które odpowiadają modelom w kodzie.
W celu wprowadzenia zmian z migracji do bazy danych należy skorzystać z polecenia Update-Database. Na rysunku 6.3 przedstawiono przykładowy plik migracyjny, zawierający informację o tworzonej nowej tabeli.
\begin{figure}[H]
    \begin{lstlisting}
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Infrastructure.Migrations;

/// <inheritdoc />
public partial class InitializeDatabase : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "PostcardsImages",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                ImageBase64 = table.Column<string>(type: "nvarchar(max)", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_PostcardsImages", x => x.Id);
            });
...
    migrationBuilder.CreateIndex(
                name: "IX_Postcards_ImageId",
                table: "Postcards",
                column: "ImageId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "PostcardsImages");
        }
    }
}
    \end{lstlisting}
\caption{Automatycznie wygenerowany plik migracyjny}
\label{fig:pseudokod:listings}
\end{figure}

\subsection{Interfejs}
Interfejs w C\# podobnie jak w innych obiektowych językach programowania to abstrakcyjny typ posiadający jednie deklaracje. Nie możemy stworzyć na jej podstawie obiektu, natomiast każda klasa lub struktura może zaimplementować dowolnie wiele interfejsów. Warunkiem do poprawnego użycia interfejsu jest konieczność implementacji wszystkich zdefiniowanych w interfejsie metod. Interfejsów używamy w celu osiągnięcia pewnego poziomu abstrakcji. Przykładem użycia jest interfejs IRepository, po którym to dziedziczy każde z repozytoriów. Ponadto każde repozytorium oraz serwis posiadają swój indywidualny interfejs. Stosowane jest to w celu poprawnej implementacji architektury Onion Architecture. Dla przykładu implementacja repozytoriów znajduje się w projekcie Infrastructure, natomiast ich interfejsy znajdują się w warstwie Domain. Jest tak, ponieważ oddzielamy w ten sposób logikę biznesową od domeny. Ułatwia to późniejsze testowanie aplikacji. 

\subsection{Wstrzykiwanie zależności}
Dependency injection – wstrzykiwanie zależności stosowane jest do zarządzania zależnościami w ramach całej solucji. W ramach konkretnych projektów może być potrzeba na zarejestrowanie usługi i/lub jej użycie. W ramach rejestracji usług interfejs IServiceCollection dostarcza metody. Trzy główne oraz najczęściej stosowane to: AddScoped, AddTransient i AddSingleton. 
\textbf{AddScoped} -- usługa tworzona jest raz podczas pojedynczego żądania HTTP, przy każdym zapytaniu otrzymujemy nowy obiekt 
\textbf{AddTransient} -- dla każdego żądania usługi zostaje tworzona nowa instancja 
\textbf{AddSingleton} -- to nic innego jak użycie wzorca projektowego Singleton. Pozwala stworzyć usługę tylko raz podczas trwania działania aplikacji. Używane jest podczas gdy dane które są w tej usłudze rejestrowane, są współdzielone w wielu miejscach. 


\subsection{Uwierzytelnianie i autoryzacja (JWT)}
We współczesnych implementacjach aplikacji ważne są pojęcia takie jak uwierzytelnianie oraz autoryzacja. Istotny jest poziom bezpieczeństwa użytkowników oraz ich danych. Często są to dane wrażliwe, które po dostaniu się w niepowołane ręce mogą wyrządzić wiele szkód użytkownikowi jak i wiele problemów organizacji oraz twórcą wadliwego oprogramowania. 

Uwierzytelnianie to proces, podczas którego potwierdzamy tożsamość użytkownika. Celem jest upewnienie się, że osoba, która wykonuje pewne żądanie może uzyskać zasób lub jego część. Uwierzytelniamy się w systemie np. poprzez podanie hasła, użycie karty dostępu lub poprzez skorzystanie z zewnętrznych serwisów. 

Autoryzacja to z kolei proces, który odpowiada na pytanie “Czy jesteś uprawniony to zrobić?”. Użytkownicy po zalogowaniu mają różne uprawnienia do zasobów. Związane jest to z różnymi rolami oraz uprawnieniami w aplikacji, organizacji. To za pomocą autoryzacji jesteśmy w stanie ograniczyć dostęp do zasobów. 

Na rysunku 6.4 przedstawiono w sposób schematyczny proces uwierzytelniania.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jwt.png}
    \caption{JWT przepływ uwierzytelniania}
    \label{JWT}
\end{figure}

\subsection{Proces uwierzytelniania} 
Proces uwierzytelniania zaczyna się od użytkownika oraz aplikacji klienckiej z wbudowanym formularzem logowania. Użytkownik po wpisaniu danych logowania wysyła prośbę o uwierzytelnienie na serwer. Ten natomiast sprawdza czy podane dane są zgodne ze stanem faktycznym w bazie danych. Następnie tworzy token, który zawiera informacje o użytkowniku oraz długości życia sesji. Przekazuje je do aplikacji klienta. Klient posiadając taki token ma możliwość z dalszego korzystania z aplikacji oraz dostępu do zablokowanych źródeł. Podczas każdego autoryzowanego zapytania klient wysyła w nagłówku otrzymany token, co pozwala serwerowi na dalszą autoryzację oraz uwierzytelnianie użytkownika. W przypadku niepoprawnego tokenu lub błędnych danych przekazanych na serwer, aplikacja klienta odmówi dostępu do niedostępnych danych. 

\subsection{Czym jest token JWT?} 
JWT (JSON Web Token) - token wydawany przez serwer. Jest to ciąg znaków kodowany do Base64. Jest on nie szyfrowany, oznacza to, że każdy jest w stanie odkodować jego zawartość. Co za tym, nie mogą znajdować się w nim dane wrażliwe, a jedynie informacje o nazwie użytkownika, jego id lub podobne. Każdy token ma określoną długość życia. W ramach każdego zapytania długość ta może być przedłużana przy pomocy RefreshTokena, aby zachować ciągłość działania aplikacji bez potrzeby ponownego logowania. 

RefreshToken to specjalny token, który zostaje użyty w przypadku, gdy nasz token dostępu utraci swoją ważność. RefreshToken ma dłuższy czas życia niż token dostępu. 

W skład tokenu wchodzi: nagłówek, payload, podpis tokena. Nagłówek to informacja o użytym algorytmie podpisywania tokena. Payload jest to lista wszystkich claimsów. Podpis tokena to suma kontrola. Claim to informacja o danych zalogowanego użytkownika. Przydatne podczas tworzenia tokenów JWT. Każdy token JWT może posiadać parę różnych Claimsów.  

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{jwtdecode.png}
    \caption{Przykładowe zdekowodanie tokenu JWT }
    \label{JWTDecode}
\end{figure}

\subsection{Data seeder} 
W celu ułatwienia procesu deweloperskiego na nasze wewnętrzne potrzeby stworzony został mechanizm wprowadzania danych. Jest to specjalny zestaw klas oraz metod, które wywoływane są jedynie na środowisku testowym. Metody te wprowadzają dane testowe do naszej bazy danych.  

Główną klasą, która zarządza danymi jest klasa DataSeeder. Posiada metodę Seed(), która jest wywoływana wraz z uruchomieniem programu. Sprawdza ona czy nasze połączenie z bazą testową jest prawidłowe oraz następnie dla każdej tabeli sprawdza czy posiada ona już jakieś testowe dane. Jeśli dana tabela nie posiada danych testowych to za pomocą odpowiadających im klas statycznych wprowadza dane testowe do tabeli. Dzięki temu rozwiązaniu dane testowe nie są dublowane przy każdym uruchomieniu aplikacji, a jedynie w momencie, gdy tabela jest pusta. Takie rozwiązanie bardzo ułatwia testowanie aplikacji oraz symulowanie rzeczywistego działania na danych. 

\subsection{Cachowanie} 
Podczas tworzenia aplikacji backendowej ważnym aspektem jest jego optymalizacja oraz szybkość działania. Jednym z mechanizmów pozwalającym zwiększyć wydajność aplikacji jest mechanizm cachowania, czyli przechowywania tymczasowych kopii. Cache obejmuje przechowywanie danych pozyskanych z bazy danych, plików które są dostępne z poziomu backendu. Stosowanie cachingu zwiększa wydajność poprzez ograniczenie ilości powtórnie wykonywanych operacji odczytu. Dla przykładu, jeżeli użytkownik odczyta jakieś dane, a w niedalekiej przyszłości zrobi to ponownie, to dzięki zastosowaniu mechanizmu cache ta druga operacja nie będzie musiała być ponownie obliczona przez serwer. Zostaną jedynie zwrócone dane które były zapisane w pamięci podręcznej podczas pierwszego zapytania. Minusem takiego zastosowania jest oczywiście zużycie pamięci, przez co należy używać tego mechanizmu z rozwagą i jedynie w kluczowych miejscach. Druga sprawa to taka, że jeżeli dane zostały zmienione pomiędzy zapytaniami a my mamy dostęp do przestarzałego cache, który może być wynikiem błędnej implementacji, to użytkownik otrzyma niezaktualizowane dane. I to właśnie na poprawną implementację powinniśmy zwrócić uwagę. Ponieważ podczas fazy deweloperskiej utrudnia to poprawne zlokalizowanie błędów, a podczas korzystania z wydanej aplikacji zwrócić może nieaktualne dane. 
W C\#, aby zrealizować mechanizm cachowania możemy skorzystać z przestrzeni nazw Microsoft.Extensions.Caching.Memory oraz interfejsu IMemoryCache. W standardowy sposób wstrzykujemy przez kontruktor obiekt IMemoryCache, a następnie za pomocą metody Set() możemy ustawić klucz oraz wartość danej kopii. Aby poprawnie stworzyć kopię tymczasową, potrzebujemy klucza, który jednoznacznie zidentyfikuje daną kopię, dane które chcemy zapamiętać, oraz opcjonalnie ustawienia. Do skorzystania z ustawień należy użyć klasy MemoryCacheEntryOptions. To w niej możemy zawrzec takie informacje jak np. czas przechowywania kopii w pamięci, jego priorytetu oraz rozmiar danych. Do tworzenia kluczy stworzona została statyczna klasa CacheKeyGenerator. Posiada przeciążoną metodę GetKey(), która to przyjmuje jako argumentu różne wartości, zależne od kontekstu aplikacji. 

Mechanizm cache zastosowaliśmy podczas pobierania danych pocztówek oraz użytkownika. Związane jest to z tym, że powyższe wartości bardzo rzadko ulegają zmianie. Dzięki temu serwer nie musi za każdym zapytaniem ponownie przetwarzać danych, co wpływa na szybkość z jaką otrzymujemy dane z serwera.

\subsection{Mapper} 
Mapowanie, czyli funkcja, która zamienia jeden obiekt do postaci innego obiektu. Stosowana jest w celu uniknięcia przypisywania każdego pola do nowego obiektu, pozwala to uniknąć powtórzeń w kodzie oraz usprawnić proces przekazywania danych. Częstym miejscem w kodzie, gdzie stosuje się mapowanie np. przekazywanie obiektu z zapytania użytkownika do następnej warstwy aplikacji. Na tym etapie otrzymujemy od użytkownika szczątkowe informacje o obiekcie, ale przy pomocy mappera tworzymy nowy obiekt, który zawiera brakujące pola. Ten nowy obiekt następnie może posłużyć do wykonania działań na bazie danych przy pomocy repozytoriów.

W kodzie zastosowaliśmy dwa podejścia do mappera. Pierwsze, z wykorzystaniem biblioteki AutoMapper, która to po uprzednim skonfigurowaniu pozwala w znaczący sposób zautomatyzować proces mapowania. Służą do tego wewnętrzne funkcje biblioteki. Każdy z obiektów DTO (Data Transfer Object), czyli obiektów transferów danych, posiada zaimplementowaną metodę Map. Ponadto posiadamy osobną klasę AutoMapperConfig, w której to znajduje się dalsza część mapowania obiektów.

Drugim podejściem jest mapowanie manualne przy pomocy ręcznie napisanych klas. Wszystkie nasze klasy mapera znajdują się w folderze /Application/Mapping/Manual. Są to klasy statyczne które jako argument przyjmują obiekt klasy wchodzącej, a zwracają obiekt klasy docelowej.

Różnica pomiędzy oboma podejściami jest taka, że w podejściu z wykorzystaniem AutoMappera, wiele zadań jest wykonanych automatycznie bez naszego udziału. Natomiast potrzebna jest wcześniejsza konfiguracja, która miejscami może być o wiele trudniejsza. W przypadku manualnych maperów mamy do czynienia z większą ilością kodu, jednak pisanie tych klas jest bardzo proste i mamy większą kontrolę nad procesem mapowania np. w przypadku debugowania kodu.

\subsection{Swagger}
Swagger to narzędzie, które pozwala w łatwy oraz przystępny sposób na korzystanie z naszego API. Dodatkowo pełni funkcję dokumentacji. Dane te można eksportować i użyć w Postmanie lub innych programach do testowania API. Każdy z endpointów możemy dowolnie testować. Można przekazywać dowolne dane, a dzięki wbudowanym mechanizmom istnieje możliwość wstrzyknięcia tokenu JWT, dzięki czemu nie mamy żadnych ograniczeń. W naszej aplikacji serwerowej, Swagger uruchamiany jest automatycznie podczas rozpoczęcia działania aplikacji. Jego sesja gaśnie wraz z zamknięciem okna przeglądarki lub wyłączenia backendu.

\section{Ważne funkcjonalności}
\subsection{Wzór Haversine}
W celu poprawnej implementacji systemu powiadomień oraz systemu odbierania pocztówek, należy obliczyć odległość ortodromiczną. Odległość ortodromiczna to najkrótsza droga pomiędzy dwoma punktami na powierzchni kuli. W tym celu posłuży wzór Haversine.

    \begin{equation}
    d = 2R \arcsin\left( \sqrt{\sin^2\left(\frac{{\text{{lat}}_2 - \text{{lat}}_1}}{2}\right) + \cos(\text{{lat}}_1) \cdot \cos(\text{{lat}}_2) \cdot \sin^2\left(\frac{{\text{{lon}}_2 - \text{{lon}}_1}}{2}\right)} \right),
    \end{equation}
    gdzie:
    \begin{align*}
    \text{{lat}}_1 & : \text{{szerokości geograficzna pocztówki}} \\
    \text{{lat}}_2 & : \text{{szerokości geograficzna użytkownika}} \\
    \text{{lon}}_1 & : \text{{długość geograficzna}} \\
    \text{{lon}}_2 & : \text{{długość geograficzna}} \\
    R & : \text{{promień ziemi}}
    \end{align*}

Powyższy wzór został wykorzystany w aplikacji serwerowej. Jest to jedna z najważniejszych funkcji w programie, ponieważ to ona mówi o tym czy użytkownik znajduje się w zasięgu odebrania pocztówki.
    
\subsection{Uwierzytelnianie}
Uwierzytelnianie jako kluczowy proces aplikacji, powinien być odpowiednio zabezpieczony oraz obsługiwany. Ważne jest, aby hasła były zapisywane w bazie danych w formie zahaszowanej, a następnie, aby proces logowania odpowiednio dostosowywał dane logowania pod zahaszowaną formę danych.

Metoda, która obsługuje rejestrację użytkownika zawiera wiele walidatorów. Na każdym etapie sprawdzamy czy podane dane do rejestracji są prawidłowe. Hasła muszą być takie same, nie mogą być za krótkie. Email musi być unikalny oraz posiadać poprawną składnie. Jeżeli warunki te zostaną spełnione to zostaje założone nowe konto użytkownika. Hasło zostaje zapisane w bazie danych w postaci zahaszowanej. Na rysunku 6.6 znajduje się implementacja metody rejestracji użytkownika. Jako argument funkcja przyjmuje obiekt DTO - RegisterUserDto. Następnie w kolejnych krokach dane te poddane są walidacji. Po jej poprawnym przejściu zostaje utworzony nowy użytkownik.

\begin{figure}[H]
    \begin{lstlisting}
public async Task<RegisterResponse> Register(RegisterUserDto registerUserDto)
{
    RegistrationResult result = RegistrationResult.Success;
    if (registerUserDto.Password != registerUserDto.ConfirmPassword)
    {
        result = RegistrationResult.PasswordsDoNotMatch;
    }
    if (registerUserDto.Password.Length < UserServiceConstants.MinPasswordLength)
    {
        result = RegistrationResult.WeakPassword;
    }
    if (!EmailRegex.IsValidEmail(registerUserDto.Email))
    {
        result = RegistrationResult.IncorrectEmail;
    }
    bool isEmailInUse = _userRepository.IsEmailInUse(registerUserDto.Email);
    if (isEmailInUse)
    {
        result = RegistrationResult.EmailAlreadyExists;
    }
    if (result != RegistrationResult.Success)
    {
        throw new Exception(result.ToString());
    }
    User newUser = _mapper.Map<User>(registerUserDto);
    string hashedPassword = _passwordHasher.HashPassword(newUser, registerUserDto.Password);
    newUser.Password = hashedPassword;
    newUser.Role = "USER";
    newUser.CreatedAt = DateTime.UtcNow;

    User user = await _userRepository.Insert(newUser);
    await _userStatsRepository.Insert(new UserStat() { Id = user.Id, PostcardsReceived = 0, PostcardsSent = 0, Score = 0 });
    await _addressRepository.Insert(new Address() { Id = user.Id });
    await _userDetailRepository.Insert(new UserDetail() { Id = user.Id });
    RegisterResponse registerResponse = _mapper.Map<RegisterResponse>(user);
    return registerResponse;
}
    \end{lstlisting}
\caption{Metoda rejestracji użytkownika}
\label{fig:pseudokod:listings}
\end{figure}

W celu poprawnego przetworzenia procesu logowania hasło musimy zweryfikować przy pomocy specjalnej funkcji VerifyHashedPassword, która to sprawdza czy zahaszowane hasło jest tym samym hasłem, które podaje użytkownik w formularzu logowania. 

Proces logowania został przedstawiony na rysunku 6.7. Przekazujemy obiekt LoginUserDto, który zawiera dane logowania.
\begin{figure}[H]
    \begin{lstlisting}
public Task<LoginResponse> Login(LoginUserDto loginUserDto)
{
    User storedUser = _userRepository.GetUserByEmail(loginUserDto.Email) ?? throw new Exception("User not found");
    PasswordVerificationResult passwordResult = _passwordHasher.VerifyHashedPassword(storedUser, storedUser.Password, loginUserDto.Password);
    if (passwordResult != PasswordVerificationResult.Success)
    {
        throw new Exception("Password is incorrect");
    }

    User userDataForClaims = _userRepository.GetUserByEmail(loginUserDto.Email);
    LoginResponse loginResponse = new LoginResponse() { Token = _userRepository.Login(userDataForClaims) };
    return Task.FromResult(loginResponse);
}
    \end{lstlisting}
\caption{Metoda rejestracji użytkownika}
\label{fig:pseudokod:listings}
\end{figure}

Po zakończeniu procesu logowania sukcesem, zwracany jest token JWT. Na dalszym etapie obsłuży on procesy związane z uwierzytelnianiem oraz autoryzacją. Jak możemy zauważyć tworzona jest lista Claimsów. Zawiera ona informację, które następnie będą dostępne z poziomu tokena JWT. Są to informacje o ID użytkownika, jego nicku, emailu oraz roli.

Na rysunku 6.8 przedstawiony został proces tworzenia tokenu JWT. Na początku definiujemy Claimsy, w kolejnych krokach długość życia tokenu.
\begin{figure}[H]
\begin{lstlisting}
public string Login(User user)
{
    List<Claim> claims = new List<Claim>()
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
        new Claim(ClaimTypes.Name, user.NickName),
        new Claim(ClaimTypes.Email, user.Email),
        new Claim(ClaimTypes.Role, user.Role),
    };

    SymmetricSecurityKey key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authenticationSettings.JwtKey));
    SigningCredentials credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    DateTime expires = DateTime.Now.AddDays(_authenticationSettings.JwtExpireDays);

    JwtSecurityToken token = new JwtSecurityToken(
        _authenticationSettings.JwtIssuer,
        _authenticationSettings.JwtIssuer,
        claims,
        expires: expires,
        signingCredentials: credentials
    );

    JwtSecurityTokenHandler tokenHandler = new JwtSecurityTokenHandler();
    return tokenHandler.WriteToken(token);
}
\end{lstlisting}
\caption{Metoda tworząca token JWT}
\label{fig:pseudokod:listings}
\end{figure}

\subsection{Przekazywanie pocztówki}
Przekazywanie pocztówki to proces, w którym użytkownik wybierając adresata oraz jedną ze swoich nowych pocztówek wysyła tę pocztówkę wraz z opisem. Opisem może być dowolna treść. Może to być pozdrowienie z wakacji, opisanie jakieś historii lub pewna forma komunikacji. W skład opisu wchodzi nagłówek pocztówki oraz treść właściwa. 

        \begin{figure}[H]
        \begin{lstlisting}
public async Task<UserPostcardDto> TransferPostcard(int newUserId, PostcardDto postcardDto)
{
    if (!await _userService.IsUserActive(newUserId))
    {
        throw new Exception("User is not active");
    }

    UserPostcard userPostcard = await _userPostcardRepository.GetUserPostcardByPostcardId(postcardDto.Id);
    if (!PostcardTransferValidator.IsPostcardValid(userPostcard, newUserId, _userContextService.GetUserId))
    {
        throw new Exception("Postcard is not valid");
    }

    PostcardDto postcard = await GetPostcardById(postcardDto.Id);
    UserStatDto sender = await _userStatsService.GetUserStatsById(_userContextService.GetUserId ?? userPostcard.UserId);
    UserStatDto receiver = await _userStatsService.GetUserStatsById(newUserId);

    if (postcard.IsSent)
    {
        throw new Exception("Postcard already received by user");
    }

    if (!PostcardTransferValidator.IsSenderAndReceiverValid(sender, receiver))
    {
        throw new Exception("User not found");
    }
...
        \end{lstlisting}
    \caption{Metoda tworząca token JWT 1/2}
    \label{fig:pseudokod:listings}
    \end{figure}

    \begin{figure}[H]
        \begin{lstlisting}
...
        
    sender.PostcardsSent++;
    sender.Score++;
    receiver.PostcardsReceived++;
    receiver.Score++;
    postcard.IsSent = true;
    postcard.Title = postcardDto.Title;
    postcard.Content = postcardDto.Content;

    await UpdatePostcard(postcard);
    await _userStatsService.UpdateUserStats(sender);
    await _userStatsService.UpdateUserStats(receiver);

    userPostcard.UserId = newUserId;
    UserPostcard updatedUserPostcard = await _userPostcardRepository.Update(userPostcard);
    return _mapper.Map<UserPostcardDto>(updatedUserPostcard);
}
        \end{lstlisting}
    \caption{Metoda tworząca token JWT 2/2}
    \label{fig:pseudokod:listings}
    \end{figure}

\section{Specyfikacja zewnętrzna}
\subsection{Czysty kod oraz konwencje języka C\# }
Podczas tworzenia oprogramowania ważne jest, aby tworzony kod był z zachowaniem zasad czystego kodu oraz dobrej architektury. Pozwala to w przyszłości na szybsze tworzenie nowych funkcjonalności oraz łatwiejszego odnajdowania błędów. W aplikacji serwerowej z wykorzystaniem języka C\# staraliśmy się wykorzystać wszystkie dobre oraz odgórnie ustalone reguły oraz zasady. I tak dla przykładu wszystkie klasy, nazwy metod są zapisane w notacji PascalCase, a funkcje w camelCase. Pola prywatne poprzedzone są podkreśleniem a następnie camelCase. Wykorzystany został podział funkcjonalności na mniejsze metody zamiast jednej dużej. Poprzez odpowiednie nazywanie zmiennych, metod oraz klas kod nie posiada komentarzy, ponieważ komentuje się sam. 

\subsection{Jak uruchomić?}
Są dwa sposoby na uruchomienie serwera. Po pierwsze wymagane jest działanie bazy danych. W tym celu na systemie Windows musimy posiadać zainstalowaną usługę MSSQLSERVER, aby sprawdzić, czy jest ona aktywna przechodzimy do Usług, a następnie szukamy MSSQLSERVER, powinien posiadać status uruchomiony. Po drugie musimy posiadać zainstalowaną wersję 7.0 frameworka .NET Core.  

Aby uruchomić serwer przy pomocy terminala, wchodzimy do folderu z projektem. Następnie do projektu WebAPI, a w nim wpisujemy polecenie: dotnet run. Po uruchomieniu aplikacja działa na uprzednio skonfigurowanym porcie. 

Serwer można uruchomić również wraz z trybem debugowania z poziomu środowiska programistycznego. Można do tego użyć Visual Studio, Visual Studio Code lub Rider. Mając uruchomione środowisko oraz projekt klikamy przycisk uruchomienia projektu. Projekt w tym czasie zostaje uruchomiony wraz z usługą Swagger. Poza tym mamy możliwość debugowania kodu. 

\subsection{Sposób pracy}
Przed pierwszym uruchomienia projektu ważne jest, aby posiadać zainstalowane wszystkie potrzebne zależności oraz programy, które zostały przedstawione wcześniej. Aplikacja serwerowa posiada pliki konfiguracyjne, które należy skopiować oraz dostosować pod swoje potrzeby. Są to pliki appsettings.Development.json i appsettings.Production.json. Kiedy mamy już uruchomione IDE wraz z projektem, ważne jest, aby postępować zgodnie z instrukcjami zawartymi w plikach README.md. Po pierwsze uruchomienie wszystkich migracji, abyśmy byli w stanie działać na bazie danych. W tym celu w konsoli Package Manager Console w projekcie src/Infrastructure wpisujemy polecenie: Update-Database. Gdybyśmy chcieli stworzyć nową migrację w tym celu polecenie to poprzedzamy poleceniem Add-Migration <NazwaNaszejMigracji>. W razie pomyłki ostatnią migrację można cofnąć poleceniem Remove-Migration. We wszystkich projektach wchodzących w skład systemu korzystamy z systemu kontroli wersji GIT. W związku z tym wszystkie nowe zmiany tworzymy na uprzednio utworzonym branchu, a następnie każdą zmianę wrzucamy na brancha. Aby stworzyć nowego brancha korzystamy z wewnętrznego integratora projektów GitHub Projects. To w nim tworzymy nowe zadania. Kiedy dana funkcjonalność jest zakończona zmiany dołączamy do głównej gałęzi - master. 

\subsection{Testy}
Ważnym aspektem tworzenia nowego oprogramowania jest odpowiednie uzupełnienie zaimplementowanych funkcjonalności o testy. Testy możemy podzielić na dwa główne typy.
Są to kolejno:
\begin{itemize}
    \item \textbf{Testy manualne} -- są to testy przeprowadzane ręcznie na uruchomionej aplikacji. Podczas testów backendu przydatnym narzędziem może okazać się Swagger oraz Postman. To właśnie za ich pomocą jesteśmy w stanie "strzelać" do odpowiednich endpointów oraz testować konkretne funkcjonalności. Ważne, aby na każdym etapie tworzenia kodu, sprawdzać skrupulatnie nowe implementacje, aby były one jak najbardziej pozbawione błędów.
    \item \textbf{Testy automatyczne} -- czyli testy, które pozwalają zautomatyzować proces testowania. Dzięki tworzeniu testów automatycznych jesteśmy w stanie ciągle sprawdzać czy nasza aplikacja będzie działała poprawnie. Przydatne podczas tworzenia nowych rozwiązań. Oszczędza to sporo czasu, ponieważ zamiast kolejnego testowania manualnego lub debugowania błędów, to właśnie testy automatyczne wychwycą wcześniej niepożądane zachowania.
\end{itemize}

W definicji testów automatycznych istnieje piramida testów. Jest to podział testów automatycznych ze względu na typ funkcjonalności.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{testy.png}
    \caption{Piramida testów}
    \label{Tests}
\end{figure}

\subsubsection{Piramida testów:}
\begin{itemize}
    \item \textbf{E2E (end-to-end)} -- znajdują się na samym szczycie piramidy. Najdroższe oraz najbardziej czasochłonne w implementacji. W ich skład wchodzą narzędzia, które symulują zachowania użytkownika. Głównie w warstwie wizualnej, poprzez interakcję z interfejsem graficznym.
    \item \textbf{Integracyjne} -- dzięki nim sprawdzamy jak nasze komponenty oraz moduły aplikacji współpracują ze sobą. Możliwe jest również testowanie zachowań z zewnętrznymi funkcjonalnościami.
    \item \textbf{Jednostkowe} -- będące na samym dole piramidy, testy, które są najczęściej spotykane w aplikacji. Ich celem jest sprawdzenie pojedynczych funkcjonalności lub komponentów. Z pomocą przychodzi wcześniej zaimplementowana abstrakcja, która pozwala odizolować daną funkcjonalność od części systemu. Posłużyć mogą w tym zamockowane dane. Mock, czyli dane które podstawiamy za właściwą implementację.
\end{itemize}
Struktura testów jednostkowych. 
Każdy serwis posiada oddzielną klasę do testów. 
Za pomocą konstruktora, wstrzykujemy odpowiednio zamockowane dane, oraz testowany przez nas serwis.

Na poniższym rysunku 6.12 przedstawiona została przykładowa klasa testów jednostkowych.
    \begin{figure}[H]
        \begin{lstlisting}
namespace Tests;

public class UserServiceTests
{
    private readonly Mock<IUserRepository> _userRepositoryMock;
    private readonly Mock<IMapper> _mapperMock;
    private readonly Mock<IPasswordHasher<User>> _passwordHasherMock;
    private readonly UserService _userService;

    public UserServiceTests()
    {
        _userRepositoryMock = new Mock<IUserRepository>();
        _mapperMock = new Mock<IMapper>();
        _passwordHasherMock = new Mock<IPasswordHasher<User>>();
        _userService = new UserService(
            contextService: null,
            userRepository: _userRepositoryMock.Object,
            userStatsRepository: null,
            userDetailRepository: null,
            addressRepository: null,
            userFriendsRepository: null,
            postcardDataRepository: null,
            mapper: _mapperMock.Object,
            passwordHasher: _passwordHasherMock.Object
        );
    }
}
...
        \end{lstlisting}
    \caption{Przykład klasy do testów jednostkowych}
    \label{fig:pseudokod:listings}
    \end{figure}

\subsubsection{Wzorzec AAA}
Nazwa pochodzi od wzorca \textbf{Arrange - Act - Assert}. Jest to główna idea tworzenia testów jednostkowych. Arrange odpowiada za organizację danych wejściowych. Są to dane, które chcemy przetestować i od których oczekujemy odpowiedniego wyniku. Act to konkretne wywołanie metody. Natomiast Assert to porównanie wyników końcowych z danymi wcześniej przez nas podstawionymi. Ponadto każdą z metod nazywamy w odpowiedni sposób, zgodny z ustaloną konwencją. Czyli opis wykonywanej akcji, wraz z oczekiwanym rezultatem testu.
\begin{itemize}
    \item \textbf{GetAll\_ShouldReturnAllUsers} - metoda pobierająca wszystkich użytkowników, zwraca wszystkich użytkowników.
    \item \textbf{Login\_ValidCredentials\_ShouldReturnToken} - metoda logowania, zawierająca poprawne dane, powinna zwrócić token uwierzytelnienia.
    \item \textbf{Login\_InvalidEmail\_ShouldThrowInvalidLoginException} - metoda logowania, zawiera błędny adres e-mail, zwraca wyjątek.
\end{itemize}

Rysunek 6.13 przedstawia jedną z metod klasy testowej. Metoda posiada dekorator [Fact], który świadczy o tym, że metoda jest metodą testową.
    \begin{figure}[H]
        \begin{lstlisting}
[Fact]
public async Task Login_ValidCredentials_ShouldReturnToken()
{
    // Arrange
    LoginUserDto loginUserDto = new LoginUserDto { Email = "test@example.com", Password = "password" };
    User storedUser = new User { Email = "test@example.com", Password = "hashedPassword" };
    _userRepositoryMock.Setup(repo => repo.GetUserByEmail(loginUserDto.Email)).Returns(storedUser);
    _passwordHasherMock.Setup(hasher => hasher.VerifyHashedPassword(storedUser, storedUser.Password, loginUserDto.Password))
        .Returns(PasswordVerificationResult.Success);
    _userRepositoryMock.Setup(repo => repo.Login(storedUser)).Returns("token");

    // Act
    LoginResponse result = await _userService.Login(loginUserDto);

    // Assert
    Assert.Equal("token", result.Token);
}
        \end{lstlisting}
    \caption{Przykład klasy do testów jednostkowych}
    \label{fig:pseudokod:listings}
    \end{figure}


W projekcie wykorzystaliśmy bibliotekę xunit do pisania testów jednostkowych. Wszystkie napisane przez nas testy znajdują się w osobnym projekcie w katalogu /Tests. Podczas pisania testów wspomagaliśmy się również dodatkową biblioteką do tworzenia Mocków, jest to biblioteka Moq.

Na wynik poprawnego wykonania testów, często mówimy, że świecą się na zielono. Jest to moment, w którym wszystkie testy przeszły prawidłowo. Uzyskany rezultat możemy zaobserwować poniżej na rysunku 6.14
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{poprawneTesty.png}
    \caption{Testy na zielono}
    \label{SuccessTests}
\end{figure}

% ==========================================================================================
% ==========================================================================================
% ===================== BACKEND  ==========================================================================================





\chapter{Podsumowanie i wnioski}
\label{ch:Podsumowanie}

\section{Dalsze kierunki rozwoju aplikacji}

\section{Problemy napotkane w trakcie pracy}

\section{Uzyskane wyniki w świetle postawionych celów i wymagań}







\backmatter

%\bibliographystyle{plplain}  % bibtex
%\bibliography{biblio} % bibtex
\printbibliography           % biblatex
\addcontentsline{toc}{chapter}{Bibliografia}

\begin{appendices}

% TODO
\chapter{Spis skrótów i symboli}

\begin{itemize}
    \item ORM -- Object Relational Mapping - Mapowanie obiektowo-relacyjne
    \item Framework -- platforma programistyczna
    \item Backend -- wartwa dostępu do danych
    \item Dependency Injection -- wstrzykiwanie zależności
    \item JWT (JSON Web Token) -- token uwierzytelniania
    \item Endpoint -- punkt końcowy komunikacji
    \item HTTP -- Hypertext Transfer Protocol
    \item HTTPS -- Hypertext Transfer Protocol Secure
    \item CRUD -- CREATE READ UPDATE DELETE
    \item Dependency injection (DI) -- wstrzykiwanie zależności
    \item DTO (Data Transfer Object) -- obiekt transferu danych
    \item IDE -- zintegrowane środowisko programistyczne
\end{itemize}



% TODO
\chapter{Źródła}
% backend
https://www.ovhcloud.com/pl/learn/what-is-rest-api/ 
https://masterbranch.pl/uwierzytelnianie-w-api-czyli-bearer-token/ 
https://jwt.io/ 
https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet-framework
https://pl.wikipedia.org/wiki/Ortodroma 
% backend




% Jeżeli w pracy konieczne jest umieszczenie długich fragmentów kodu źródłowego, należy je przenieść w to miejsce.

% \begin{lstlisting}
% if (_nClusters < 1)
% 	throw std::string ("unknown number of clusters");
% if (_nIterations < 1 and _epsilon < 0)
% 	throw std::string ("You should set a maximal number of iteration or minimal difference -- epsilon.");
% if (_nIterations > 0 and _epsilon > 0)
% 	throw std::string ("Both number of iterations and minimal epsilon set -- you should set either number of iterations or minimal epsilon.");
% \end{lstlisting}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Pakiet minted wymaga odkomentowania w pliku config/settings.tex   %
% importu pakietu minted: \usepackage{minted}                       %
% i specjalnego kompilowania:                                       %
% pdflatex -shell-escape praca                                      %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

%\begin{minted}[linenos,breaklines,frame=lines]{c++}
%if (_nClusters < 1)
%   throw std::string ("unknown number of clusters");
%if (_nIterations < 1 and _epsilon < 0)
%   throw std::string ("You should set a maximal number of iteration or minimal difference -- epsilon.");
%if (_nIterations > 0 and _epsilon > 0)
%   throw std::string ("Both number of iterations and minimal epsilon set -- you should set either number of iterations or minimal epsilon.");
%\end{minted}


% TODO
\chapter{Lista dodatkowych plików, uzupełniających tekst pracy} 


W systemie do pracy dołączono dodatkowe pliki zawierające:
\begin{itemize}
\item źródła programu,
\item film pokazujący działanie opracowanego oprogramowania lub zaprojektowanego i~wykonanego urządzenia,
\end{itemize}


\listoffigures
\addcontentsline{toc}{chapter}{Spis rysunków}
\listoftables
\addcontentsline{toc}{chapter}{Spis tabel}

\end{appendices}

\end{document}


%% Finis coronat opus.

